<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é­”æ³•æ£®æ—æ•¸å­¸æ¢éšª</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft JhengHei', 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        @media (max-width: 600px) {
            .container {
                padding: 10px;
            }
        }

        /* æ¨™é¡Œå€åŸŸ */
        .game-title {
            text-align: center;
            color: white;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .game-title h1 {
            font-size: clamp(28px, 6vw, 48px);
            margin-bottom: 10px;
            animation: titleFloat 3s ease-in-out infinite;
        }

        .coin-tag {
            display: inline-block;
            background: #ffd700;
            color: #8b4513;
            padding: 5px 15px;
            border-radius: 20px;
            margin: 5px;
            font-weight: bold;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.1);
            border: 2px solid #daa520;
        }

        .coin-container {
            margin: 5px 0;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 3px;
            max-width: 100%;
            padding: 5px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 15px;
        }

        .coin-row {
            display: flex;
            flex-wrap: wrap;
            justify-content: flex-start;
            align-items: center;
            width: 100%;
            gap: 2px;
            margin-bottom: 3px;
            padding: 3px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 8px;
        }

        .coin-row-count {
            margin-left: auto;
            font-weight: bold;
            color: #333;
            font-size: clamp(0.8em, 3vw, 1em);
            padding: 1px 6px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 5px;
            min-width: 35px;
            text-align: center;
        }

        .coin-row:last-child {
            margin-bottom: 0;
        }

        .coin-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: rgba(255, 255, 255, 0.8);
            padding: 2px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .coin-img {
            width: clamp(30px, 8vw, 50px);
            height: auto;
            min-height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.2));
        }

        .coin-wrapper.is-bill .coin-img {
            width: clamp(50px, 12vw, 80px);
        }

        .coin-img svg {
            width: 100%;
            height: 100%;
            max-height: 50px;
        }

        .coin-count {
            font-weight: bold;
            color: #333;
            font-size: 1.1em;
        }

        @keyframes titleFloat {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-10px);
            }
        }

        /* é—œå¡åœ°åœ– */
        .level-map {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 25px;
            margin-top: 30px;
        }

        .level-card {
            background: linear-gradient(135deg, #ffffff 0%, #f0f0f0 100%);
            border-radius: 20px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .level-card::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transform: rotate(45deg);
            transition: all 0.5s;
        }

        .level-card:hover::before {
            left: 100%;
        }

        .level-card:hover {
            transform: translateY(-10px) scale(1.02);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.4);
        }

        .level-card h3 {
            font-size: clamp(20px, 4vw, 26px);
            color: #667eea;
            margin-bottom: 15px;
            text-align: center;
        }

        .level-icon {
            font-size: clamp(40px, 8vw, 60px);
            text-align: center;
            margin-bottom: 15px;
        }

        .level-records {
            display: flex;
            justify-content: space-around;
            margin-top: 15px;
            gap: 10px;
        }

        .record-item {
            text-align: center;
            flex: 1;
        }

        .record-item .label {
            font-size: clamp(12px, 2.5vw, 14px);
            color: #666;
            margin-bottom: 5px;
        }

        .stars {
            font-size: clamp(16px, 3.5vw, 20px);
            color: #ffd700;
        }

        /* ç·´ç¿’å€åŸŸæ¨£å¼ */
        .practice-section {
            margin-top: 50px;
            padding: clamp(15px, 4vw, 30px);
            background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
            border-radius: 25px;
            box-shadow: 0 15px 35px rgba(255, 154, 158, 0.4);
        }

        .practice-title {
            text-align: center;
            color: white;
            font-size: clamp(24px, 5vw, 32px);
            margin-bottom: 25px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            animation: practiceGlow 2s ease-in-out infinite alternate;
        }

        @keyframes practiceGlow {
            from {
                text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3), 0 0 10px rgba(255, 255, 255, 0.5);
            }

            to {
                text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3), 0 0 20px rgba(255, 255, 255, 0.8);
            }
        }

        .practice-map {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            justify-items: center;
        }

        .practice-card {
            background: linear-gradient(135deg, #ffffff 0%, #f8f9ff 100%);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            border: 3px solid transparent;
            background-clip: padding-box;
            max-width: 400px;
        }

        .practice-card::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255, 204, 0, 0.3), transparent);
            transform: rotate(45deg);
            transition: all 0.5s;
        }

        .practice-card:hover::before {
            left: 100%;
        }

        .practice-card:hover {
            transform: translateY(-10px) scale(1.05);
            box-shadow: 0 20px 50px rgba(255, 154, 158, 0.5);
            border-color: #ffcc00;
        }

        .practice-card h3 {
            font-size: clamp(22px, 4vw, 28px);
            color: #ff6b6b;
            margin-bottom: 15px;
            text-align: center;
            font-weight: bold;
        }

        .practice-icon {
            font-size: clamp(50px, 10vw, 70px);
            text-align: center;
            margin-bottom: 20px;
            animation: practiceFloat 3s ease-in-out infinite;
        }

        @keyframes practiceFloat {

            0%,
            100% {
                transform: translateY(0) rotate(0deg);
            }

            50% {
                transform: translateY(-8px) rotate(5deg);
            }
        }

        .practice-description {
            text-align: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            border-radius: 12px;
            font-size: clamp(14px, 3vw, 16px);
            font-weight: bold;
            margin-top: 15px;
        }

        /* é›£åº¦é¸æ“‡å½ˆçª— */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 25px;
            padding: clamp(15px, 5vw, 30px);
            max-width: 500px;
            width: 100%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            animation: modalSlideIn 0.3s ease;
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-50px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .modal-content h2 {
            color: #667eea;
            text-align: center;
            margin-bottom: 25px;
            font-size: clamp(22px, 5vw, 28px);
        }

        .difficulty-buttons {
            display: flex;
            gap: 15px;
            flex-direction: column;
        }

        .difficulty-btn {
            padding: 20px;
            font-size: clamp(18px, 4vw, 22px);
            border: none;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .difficulty-btn.easy {
            background: linear-gradient(135deg, #84fab0 0%, #8fd3f4 100%);
            color: #2c5f2d;
        }

        .difficulty-btn.hard {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
            color: #8b2500;
        }

        .difficulty-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        }

        .close-modal {
            background: #ccc;
            color: #333;
            margin-top: 15px;
            padding: 12px;
            font-size: clamp(16px, 3.5vw, 18px);
        }

        /* éŠæˆ²ç•«é¢ */
        .game-screen {
            display: none;
            background: white;
            border-radius: 25px;
            padding: clamp(15px, 5vw, 40px);
            max-width: 800px;
            margin: 0 auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        .game-screen.active {
            display: block;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 10px;
        }

        @media (max-width: 600px) {
            .game-header {
                justify-content: center;
                text-align: center;
            }

            .game-info {
                justify-content: center;
                width: 100%;
            }
        }

        .game-info {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .info-item {
            font-size: clamp(14px, 3vw, 18px);
            font-weight: bold;
            color: #667eea;
        }

        .back-btn {
            padding: 12px 24px;
            background: #ff6b6b;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: clamp(14px, 3vw, 16px);
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .back-btn:hover {
            background: #ee5a52;
            transform: scale(1.05);
        }

        .reset-container {
            text-align: center;
            margin-top: 30px;
            padding: 20px;
        }

        .reset-btn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.4);
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .reset-btn:hover {
            background: rgba(255, 0, 0, 0.4);
            border-color: #ff6b6b;
        }

        .question-area {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 20px;
            padding: clamp(15px, 4vw, 30px);
            margin-bottom: 20px;
            min-height: 150px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .question-text {
            font-size: clamp(16px, 4vw, 24px);
            color: #333;
            text-align: center;
            margin-bottom: 10px;
            line-height: 1.4;
        }

        /* æ™‚é˜é¡¯ç¤º */
        .clock-canvas {
            width: clamp(150px, 40vw, 250px);
            height: clamp(150px, 40vw, 250px);
            border: 8px solid #333;
            border-radius: 50%;
            position: relative;
            background: white;
            margin: 20px auto;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .clock-center {
            width: 12px;
            height: 12px;
            background: #333;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
        }

        .clock-hand {
            position: absolute;
            bottom: 50%;
            left: 50%;
            transform-origin: bottom center;
            background: #333;
            transition: transform 0.5s cubic-bezier(0.4, 2.08, 0.55, 0.44);
        }

        .hour-hand {
            width: 6px;
            height: 25%;
            background: #333;
            margin-left: -3px;
        }

        .minute-hand {
            width: 4px;
            height: 35%;
            background: #666;
            margin-left: -2px;
        }

        .clock-number {
            position: absolute;
            font-size: clamp(12px, 3vw, 16px);
            font-weight: bold;
            color: #333;
            width: 20px;
            height: 20px;
            text-align: center;
            line-height: 20px;
            margin-top: -10px;
            margin-left: -10px;
            z-index: 5;
        }

        .clock-tick {
            position: absolute;
            top: 0;
            left: 50%;
            transform-origin: bottom center;
            pointer-events: none;
        }

        .clock-tick-inner {
            width: 100%;
            background: #333;
        }

        /* é‡å°å°è¢å¹•é€²ä¸€æ­¥å£“ç¸®ç©ºé–“ */
        @media (max-width: 600px) {
            .question-area {
                padding: 10px;
                margin-bottom: 10px;
                min-height: 120px;
            }

            .coin-container {
                margin: 2px 0;
                padding: 3px;
            }

            .coin-row {
                margin-bottom: 2px;
                padding: 2px;
            }

            .answers-grid {
                gap: 8px;
                margin-top: 10px;
            }

            .answer-btn {
                padding: 12px 10px;
            }
        }

        .answers-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        .answer-btn {
            padding: clamp(10px, 3vw, 20px);
            font-size: clamp(16px, 3.5vw, 20px);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            min-height: 60px;
        }

        .answer-btn:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        }

        .answer-btn:active {
            transform: translateY(0);
        }

        .answer-btn.correct {
            background: linear-gradient(135deg, #56ab2f 0%, #a8e063 100%);
            animation: correctPulse 0.5s ease;
        }

        .answer-btn.wrong {
            background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%);
            animation: wrongShake 0.5s ease;
        }

        @keyframes correctPulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.1);
            }
        }

        @keyframes wrongShake {

            0%,
            100% {
                transform: translateX(0);
            }

            25% {
                transform: translateX(-10px);
            }

            75% {
                transform: translateX(10px);
            }
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 20px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #56ab2f 0%, #a8e063 100%);
            transition: width 0.3s ease;
        }

        /* çµæœç•«é¢ */
        .result-screen {
            display: none;
            background: white;
            border-radius: 25px;
            padding: clamp(20px, 5vw, 40px);
            max-width: 600px;
            margin: 0 auto;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        .result-screen.active {
            display: block;
            animation: modalSlideIn 0.5s ease;
        }

        .result-screen h2 {
            font-size: clamp(28px, 6vw, 36px);
            color: #667eea;
            margin-bottom: 20px;
        }

        .result-stars {
            font-size: clamp(40px, 10vw, 60px);
            margin: 20px 0;
        }

        .result-message {
            font-size: clamp(18px, 4vw, 22px);
            color: #666;
            margin-bottom: 30px;
        }

        .result-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .result-btn {
            padding: 15px 30px;
            font-size: clamp(16px, 3.5vw, 18px);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .retry-btn {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        .home-btn {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
        }

        .result-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        }

        /* éŸ¿æ‡‰å¼è¨­è¨ˆ */
        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }

            .level-map {
                grid-template-columns: repeat(2, 1fr);
                gap: 20px;
            }

            .game-header {
                flex-direction: column;
                align-items: flex-start;
            }

            .answers-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .difficulty-buttons {
                gap: 12px;
            }
        }

        @media (min-width: 769px) and (max-width: 1024px) {
            .level-map {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        /* è§¸æ§å„ªåŒ– */
        @media (hover: none) and (pointer: coarse) {

            .answer-btn,
            .difficulty-btn,
            .result-btn,
            .back-btn {
                min-height: 50px;
                padding: 18px;
            }
        }
        /* çå‹µéŠæˆ²ç•«é¢æ¨£å¼ */
        #bonusGameContainer {
            touch-action: none;
            user-select: none;
        }

        .falling-star {
            pointer-events: none;
            z-index: 100;
        }

        #basket {
            font-size: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 110;
        }

        @keyframes rainbowStar {
            0% { filter: hue-rotate(0deg) drop-shadow(0 0 8px #fff); }
            100% { filter: hue-rotate(360deg) drop-shadow(0 0 12px #fff); }
        }

        /* åŠ åˆ†/æ‰£åˆ†ç‰¹æ•ˆæ¨£å¼ */
        .score-effect {
            position: absolute;
            pointer-events: none;
            font-weight: bold;
            font-size: 24px;
            animation: scoreFloat 0.8s ease-out forwards;
            z-index: 120;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        @keyframes scoreFloat {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-50px) scale(1.5); opacity: 0; }
        }

        .catch-ripple {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            animation: rippleEffect 0.5s ease-out forwards;
            z-index: 115;
        }

        @keyframes rippleEffect {
            0% { width: 0; height: 0; opacity: 0.8; border: 2px solid white; }
            100% { width: 100px; height: 100px; opacity: 0; border: 10px solid white; transform: translate(-50px, -50px); }
        }

        /* æ¶ˆæ¶ˆæ¨‚æ¨£å¼ */
        .match3-container {
            width: 100%;
            max-width: 550px;
            aspect-ratio: 1;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            border: 4px solid #8b4513;
            border-radius: 15px;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            gap: 2px;
            padding: 5px;
            position: relative;
            background: #2d5a27;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.5);
            touch-action: none;
        }

        .match3-tile {
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(26px, 6.5vw, 38px);
            cursor: pointer;
            transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275), background 0.3s;
            user-select: none;
            position: relative;
        }

        .match3-tile:hover {
            transform: scale(0.95);
            background: #fff;
        }

        .match3-tile.selected {
            background: #fff;
            box-shadow: 0 0 15px #ffd700, inset 0 0 10px #ffd700;
            transform: scale(1.1);
            z-index: 10;
        }

        .match3-tile.match {
            animation: matchPop 0.4s ease-out forwards;
        }

        @keyframes matchPop {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.3); opacity: 1; }
            100% { transform: scale(0); opacity: 0; }
        }

        .match3-tile.falling {
            transition: top 0.3s cubic-bezier(0.55, 0.055, 0.675, 0.19);
        }

        /* å°„æ“ŠéŠæˆ²æ¨£å¼ */
        .shooter-container {
            position: relative;
            width: 100%;
            height: 520px;
            background: linear-gradient(to bottom, #00111a, #00334d);
            border: 4px solid #0a3d62;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: inset 0 0 25px rgba(0,0,0,0.6);
            touch-action: none;
            cursor: crosshair;
        }
        .shooter-hud {
            position: absolute;
            top: 8px;
            left: 8px;
            color: #fff;
            font-weight: bold;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            z-index: 5;
        }
        .shooter-player, .shooter-bullet, .shooter-enemy, .shooter-explosion {
            position: absolute;
            user-select: none;
            pointer-events: none;
        }
        .shooter-player {
            width: 64px;
            height: 64px;
            transform: translate(-50%, -50%);
            filter: drop-shadow(0 0 8px rgba(255,255,255,0.4));
            font-size: 56px;
            line-height: 1;
        }
        .shooter-bullet {
            width: 8px;
            height: 20px;
            background: #ffeb3b;
            border-radius: 4px;
            box-shadow: 0 0 12px #ffeb3b;
        }
        .shooter-enemy {
            width: 60px;
            height: 60px;
            transform: translate(-50%, -50%);
            filter: drop-shadow(0 0 8px rgba(255,0,0,0.5));
            font-size: 52px;
            line-height: 1;
        }
        .shooter-explosion {
            width: 36px;
            height: 36px;
            border: 4px solid #ffd700;
            border-radius: 50%;
            opacity: 0.9;
            transform: translate(-50%, -50%) scale(0.5);
            transition: transform 0.25s ease-out, opacity 0.25s ease-out;
        }
        /* 3 åˆ†æ€ªï¼ˆğŸ‘¹ï¼‰ç‰¹æ•ˆï¼šç™¼å…‰èˆ‡è„ˆå‹•æ”¾å¤§ */
        @keyframes ogrePulse {
            0% { transform: translate(-50%, -50%) scale(1); box-shadow: 0 0 12px #ff5252, 0 0 24px rgba(255,82,82,0.5); }
            50% { transform: translate(-50%, -50%) scale(1.12); box-shadow: 0 0 18px #ff5252, 0 0 36px rgba(255,82,82,0.7); }
            100% { transform: translate(-50%, -50%) scale(1); box-shadow: 0 0 12px #ff5252, 0 0 24px rgba(255,82,82,0.5); }
        }
        .ogre-boss {
            animation: ogrePulse 1.2s ease-in-out infinite;
            /* é¡å¤–é«˜äº®ï¼šåœ¨åŸæœ¬çš„ drop-shadow ä¹‹å¤–å†åŠ ä¸Šç›’å½±æšˆå…‰ */
            box-shadow: 0 0 14px #ff5252, 0 0 26px rgba(255,82,82,0.6);
        }
        /* å°„æ“ŠéŠæˆ²ï¼šåˆ†æ•¸åœ–ç¤ºèªªæ˜ï¼ˆå³ä¸Šè§’ï¼‰ */
        .shooter-legend {
            position: absolute;
            top: 8px;
            right: 8px;
            color: #fff;
            background: rgba(0, 0, 0, 0.35);
            border: 1px solid rgba(255,255,255,0.25);
            border-radius: 10px;
            padding: 6px 8px;
            font-size: 14px;
            line-height: 1.2;
            backdrop-filter: blur(2px);
            pointer-events: none; /* ä¸é˜»æ“‹å°„æ“Š/æ‹–æ›³ */
            z-index: 6;
        }
        .shooter-legend .legend-row { display: flex; align-items: center; gap: 6px; margin: 3px 0; white-space: nowrap; }
        .shooter-legend .icon { width: 22px; text-align: center; font-size: 18px; line-height: 1; filter: drop-shadow(0 0 6px currentColor); }
        .shooter-legend .text { font-weight: 700; text-shadow: 0 2px 3px rgba(0,0,0,0.4); }
        @media (max-width: 480px) { .shooter-legend { font-size: 12px; padding: 5px 6px; } .shooter-legend .icon { font-size: 16px; width: 18px; } }

        /* è¨˜æ†¶éŠæˆ²æ¨£å¼ */
        .memory-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            max-width: 600px;
            margin: 0 auto;
            perspective: 1000px;
        }

        @media (max-width: 600px) {
            .memory-grid {
                grid-template-columns: repeat(4, 1fr);
                gap: 5px;
            }
        }

        .memory-card {
            aspect-ratio: 3/4;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
        }

        .memory-card.flipped {
            transform: rotateY(180deg);
        }

        .memory-card.matched {
            animation: matchSuccess 0.5s ease-out forwards;
        }

        @keyframes matchSuccess {
            0% { transform: rotateY(180deg) scale(1); filter: brightness(1); opacity: 1; }
            50% { transform: rotateY(180deg) scale(1.1); filter: brightness(1.5); box-shadow: 0 0 20px #ffd700; opacity: 1; }
            100% { transform: rotateY(180deg) scale(0); filter: brightness(0.8); opacity: 0; }
        }

        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(32px, 8vw, 50px);
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .card-front {
            background: linear-gradient(135deg, #a1c4fd 0%, #c2e9fb 100%);
            transform: rotateY(180deg);
        }

        .card-back {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: 2px solid white;
        }

        .card-back::after {
            content: 'ğŸŒ³';
            font-size: 1.2em;
        }

        /* å¹³æ¿æ©«å‘å„ªåŒ–ï¼šè¨˜æ†¶å¡ç‰‡æ”¹ç‚ºæ©«å‘æ’åˆ—èˆ‡æ¯”ä¾‹ */
        @media (orientation: landscape) and (min-width: 768px) and (max-width: 1199px) {
            .memory-grid {
                grid-template-columns: repeat(6, 1fr); /* 6 æ¬„ x 4 åˆ— = 24 å¼µå¡ç‰‡ï¼Œè¼ƒé©åˆæ©«å‘ */
                max-width: 900px;
                gap: 12px;
            }
            .memory-card {
                aspect-ratio: 4 / 3; /* æ”¹ç‚ºæ©«å‘æ¯”ä¾‹ */
            }
            .card-face {
                font-size: clamp(28px, 6vw, 48px); /* èª¿æ•´å­—é«”é¿å…éå¤§ */
            }
        }

        /* å¤§è¢å¹•æ©«å‘ï¼ˆæ¡Œæ©Ÿæ©«æ”¾æˆ–å¤§å‹å¹³æ¿ï¼‰å¯å†æ”¾å¯¬ä¸€é» */
        @media (orientation: landscape) and (min-width: 1200px) {
            .memory-grid {
                grid-template-columns: repeat(6, 1fr);
                max-width: 1000px;
                gap: 14px;
            }
            .memory-card { aspect-ratio: 4 / 3; }
        }

        /* å¹³æ¿ç›´å‘ï¼šç¢ºä¿24å¼µå¡ç‰‡èƒ½åœ¨å–®ä¸€ç•«é¢é¡¯ç¤ºï¼ˆ4æ¬„ x 6åˆ—ï¼‰*/
        @media (orientation: portrait) and (min-width: 768px) and (max-width: 1199px) {
            #memoryScreen { overflow: hidden; }
            #memoryScreen > p { display: none; } /* éš±è—æç¤ºæ–‡å­—ä»¥ç¯€çœå‚ç›´ç©ºé–“ */
            .memory-grid {
                /* ä»ç„¶æ˜¯4æ¬„æ’åˆ—ï¼Œä½†ç¸®æ”¾ä»¥ä¿è­‰6åˆ—åœ¨å¯è¦–é«˜åº¦å…§ */
                grid-template-columns: repeat(4, 1fr);
                gap: 8px;
                max-width: none; /* ä½¿ç”¨è¨ˆç®—å¯¬åº¦ä»¥ç¬¦åˆé«˜åº¦ */
                /* é ç•™ä¸Šæ–¹æ¨™é¡Œ/æŒ‰éˆ•ç­‰UIé«˜åº¦ï¼Œé¿å…éœ€è¦æ²å‹• */
                --ui-reserve: 240px;
                width: min(
                    95vw,
                    calc( ((((100vh - var(--ui-reserve)) - (5 * 8px)) / 6) * (3 / 4) * 4) + (3 * 8px) )
                );
                margin-left: auto;
                margin-right: auto;
            }
            .memory-card {
                aspect-ratio: 3 / 4; /* ç›´å‘æ¯”ä¾‹ï¼Œä¾¿æ–¼åœ¨ç¸±å‘è¢å¹•æ’6åˆ— */
            }
            .card-face {
                font-size: clamp(22px, 5.2vw, 40px);
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <!-- éŠæˆ²æ¨™é¡Œ -->
        <div class="game-title">
            <h1>ğŸŒ³ é­”æ³•æ£®æ—æ•¸å­¸æ¢éšª ğŸŒ³</h1>
            <p>é¸æ“‡é—œå¡é–‹å§‹å†’éšªå§ï¼</p>
        </div>

        <!-- é—œå¡åœ°åœ– -->
        <div id="levelMap" class="level-map"></div>

        <!-- ç·´ç¿’å€åŸŸ -->
        <div class="practice-section">
            <h2 class="practice-title">ğŸ”¥ ç‰¹åˆ¥ç·´ç¿’å€ ğŸ”¥</h2>
            <div id="practiceMap" class="practice-map"></div>
        </div>

        <!-- è¿·ä½ éŠæˆ²å€ -->
        <div class="mini-game-section" style="margin-top: 30px;">
            <div id="availableStarsDisplay" style="text-align: center; margin-bottom: 10px; color: #ffd700; font-weight: bold; font-size: 1.2em; text-shadow: 1px 1px 2px rgba(0,0,0,0.5);"></div>
            <h2 class="practice-title">ğŸ® è¿·ä½ éŠæˆ²å€ ğŸ®</h2>
            <div class="practice-map">
                <div class="practice-card" onclick="Match3Game.start()" style="position: relative;">
                    <div style="position: absolute; top: 10px; right: 10px; background: #ff4d4d; color: white; padding: 2px 8px; border-radius: 10px; font-size: 0.8em; font-weight: bold; box-shadow: 0 2px 4px rgba(0,0,0,0.2);">
                        ä¸€æ¬¡ 3 â­
                    </div>
                    <div class="practice-icon">ğŸ“</div>
                    <h3>æ£®æ—æ¶ˆæ¶ˆæ¨‚</h3>
                    <div class="practice-description">
                        æ”¾é¬†ä¸€ä¸‹ï¼<br>
                        ğŸ å°‡ä¸‰å€‹ç›¸åŒçš„æ°´æœé€£åœ¨ä¸€èµ·æ¶ˆé™¤å§ ğŸ‡<br>
                        <small>ç›Šæ™ºä¼‘é–’ â€¢ æ£®æ—ä¸»é¡Œ</small>
                    </div>
                </div>
                <div class="practice-card" onclick="MemoryGame.start()" style="position: relative;">
                    <div style="position: absolute; top: 10px; right: 10px; background: #ff4d4d; color: white; padding: 2px 8px; border-radius: 10px; font-size: 0.8em; font-weight: bold; box-shadow: 0 2px 4px rgba(0,0,0,0.2);">
                        ä¸€æ¬¡ 3 â­
                    </div>
                    <div class="practice-icon">ğŸ§ </div>
                    <h3>æ£®æ—è¨˜æ†¶ç‹</h3>
                    <div class="practice-description">
                        è…¦åŠ›å¤§è€ƒé©—ï¼<br>
                        ğŸ” æ‰¾å‡ºå…©å…©æˆå°çš„æ£®æ—å¤¥ä¼´å§ ğŸ¦‰<br>
                        <small>è¨˜æ†¶è¨“ç·´ â€¢ 24å¼µå¡ç‰‡</small>
                    </div>
                </div>
            </div>
        </div>

        <!-- é‡ç½®é€²åº¦å€åŸŸ -->
        <div id="resetSection" class="reset-container">
            <button class="reset-btn" onclick="UIManager.confirmReset()">ğŸ—‘ï¸ æ¸…é™¤æ‰€æœ‰æ˜Ÿæ˜Ÿè¨˜éŒ„</button>
        </div>

        <!-- ç›´æ¥é€²å…¥é€šé—œå¾Œå°éŠæˆ²ï¼ˆç§»è‡³é é¢æœ€ä¸‹æ–¹ï¼‰ -->
        <div id="directBonusSection" style="margin: 20px 0 10px; text-align: center;">
            <button onclick="SecureBonus.promptAndStart()" style="background: linear-gradient(135deg, #ffd700 0%, #ff8c00 100%); color: white; border: none; padding: 12px 18px; border-radius: 12px; font-size: 1.05em; font-weight: bold; box-shadow: 0 4px 10px rgba(0,0,0,0.2); cursor: pointer;">
                ç®¡ç†è€…è¨­å®š
            </button>
        </div>

        <!-- é›£åº¦é¸æ“‡å½ˆçª— -->
        <div id="difficultyModal" class="modal">
            <div class="modal-content">
                <h2 id="modalTitle">é¸æ“‡é›£åº¦</h2>
                <div class="difficulty-buttons">
                    <button class="difficulty-btn easy" onclick="GameEngine.startLevel(GameEngine.state.currentLevel.id, 'easy')">
                        ğŸŒ± ç°¡å–®æ¨¡å¼
                    </button>
                    <button class="difficulty-btn hard" onclick="GameEngine.startLevel(GameEngine.state.currentLevel.id, 'hard')">
                        ğŸ”¥ å›°é›£æ¨¡å¼
                    </button>
                    <button class="difficulty-btn close-modal" onclick="UIManager.closeModal()">
                        å–æ¶ˆ
                    </button>
                </div>
            </div>
        </div>

        <!-- ç®¡ç†è€…éŠæˆ²å…¥å£å½ˆçª— -->
        <div id="adminGameModal" class="modal">
            <div class="modal-content">
                <h2>ç®¡ç†è€…è¨­å®š</h2>
                <div style="margin-bottom:8px; font-weight:bold; color:#2e7d32;">ğŸ† é€šé—œå¾Œå°éŠæˆ²</div>
                <div class="difficulty-buttons" style="margin-bottom:14px;">
                    <button class="difficulty-btn" style="background: linear-gradient(135deg,#ffd700,#ff8c00); color:#fff;" onclick="UIManager.closeAdminModal(); BonusGame.start(true)">ğŸŒŸ æ˜Ÿæ˜Ÿæ”¶é›†å¤§ä½œæˆ°</button>
                    <button class="difficulty-btn" onclick="UIManager.closeAdminModal(); ShootingGame.start(true)">ğŸ¯ æ£®æ—å°„æ“Šæˆ°</button>
                </div>
                <div style="margin:10px 0 8px; font-weight:bold; color:#1565c0;">ğŸ® è¿·ä½ éŠæˆ²å€</div>
                <div class="difficulty-buttons" style="margin-bottom:14px;">
                    <button class="difficulty-btn" onclick="UIManager.closeAdminModal(); Match3Game.start(true)">ğŸ“ æ£®æ—æ¶ˆæ¶ˆæ¨‚</button>
                    <button class="difficulty-btn" onclick="UIManager.closeAdminModal(); MemoryGame.start(true)">ğŸ§  æ£®æ—è¨˜æ†¶ç‹</button>
                </div>
                <div class="difficulty-buttons">
                    <button class="difficulty-btn close-modal" onclick="UIManager.closeAdminModal()">é—œé–‰</button>
                </div>
            </div>
        </div>

        <!-- é€šé—œå¾Œå°éŠæˆ²é¸æ“‡å½ˆçª—ï¼ˆçµæœç•«é¢ 3 æ˜Ÿæ™‚é–‹å•Ÿï¼‰ -->
        <div id="resultBonusModal" class="modal">
            <div class="modal-content">
                <h2>é¸æ“‡é€šé—œå¾Œå°éŠæˆ²</h2>
                <div class="difficulty-buttons">
                    <button class="difficulty-btn" style="background: linear-gradient(135deg,#ffd700,#ff8c00); color:#fff;" onclick="UIManager.closeResultBonusModal(); BonusGame.start(true)">ğŸŒŸ æ˜Ÿæ˜Ÿæ”¶é›†å¤§ä½œæˆ°</button>
                    <button class="difficulty-btn" onclick="UIManager.closeResultBonusModal(); ShootingGame.start()">ğŸ¯ æ£®æ—å°„æ“Šæˆ°</button>
                    <button class="difficulty-btn close-modal" onclick="UIManager.closeResultBonusModal()">é—œé–‰</button>
                </div>
            </div>
        </div>

        <!-- ç®¡ç†è€…å¯†ç¢¼å½ˆçª—ï¼ˆéš±è—è¼¸å…¥æ–‡å­—ï¼‰ -->
        <div id="adminPasswordModal" class="modal" aria-hidden="true">
            <div class="modal-content">
                <h2>è¼¸å…¥å¯†ç¢¼</h2>
                <div style="margin: 10px 0 15px;">
                    <input id="adminPasswordInput" type="password" placeholder="è«‹è¼¸å…¥å¯†ç¢¼" style="width: 100%; padding: 12px 14px; font-size: 1em; border-radius: 10px; border: 1px solid #ccc; outline: none;">
                </div>
                <div id="adminPasswordError" style="display:none; color:#b00020; font-size:0.95em; margin-bottom:10px;">å¯†ç¢¼éŒ¯èª¤ï¼Œè«‹å†è©¦ä¸€æ¬¡ï¼</div>
                <div class="difficulty-buttons">
                    <button class="difficulty-btn" onclick="SecureBonus.submitPassword()">ç¢ºèª</button>
                    <button class="difficulty-btn close-modal" onclick="SecureBonus.closeModal()">å–æ¶ˆ</button>
                </div>
            </div>
        </div>

        <!-- éŠæˆ²ç•«é¢ -->
        <div id="gameScreen" class="game-screen">
            <div class="game-header">
                <div class="game-info">
                    <div class="info-item">
                        <span id="levelName">é—œå¡åç¨±</span>
                    </div>
                    <div class="info-item">
                        é¡Œç›®: <span id="questionNumber">1</span>/<span id="totalQuestions">10</span>
                    </div>
                    <div class="info-item">
                        éŒ¯èª¤: <span id="errorCount">0</span>/3
                    </div>
                </div>
                <button class="back-btn" onclick="UIManager.confirmExit()">è¿”å›åœ°åœ–</button>
            </div>

            <div class="progress-bar">
                <div id="progressFill" class="progress-fill" style="width: 0%"></div>
            </div>

            <div class="question-area">
                <div id="questionContent" class="question-text"></div>
                <div id="clockContainer"></div>
            </div>

            <div id="answersContainer" class="answers-grid"></div>
        </div>

        <!-- çµæœç•«é¢ -->
        <div id="resultScreen" class="result-screen">
            <h2 id="resultTitle">æ­å–œå®Œæˆï¼</h2>
            <div id="resultStars" class="result-stars"></div>
            <div id="resultMessage" class="result-message"></div>
            <div class="result-buttons">
                <button id="bonusBtn" class="result-btn" style="display: none; background: linear-gradient(135deg, #ffd700 0%, #ff8c00 100%); color: white; width: 100%; margin-bottom: 10px;" onclick="UIManager.openResultBonusModal()">ğŸŒŸ é€²å…¥å°éŠæˆ²çå‹µ ğŸŒŸ</button>
                <button class="result-btn retry-btn" onclick="GameEngine.retryLevel()">å†ç©ä¸€æ¬¡</button>
                <button class="result-btn home-btn" onclick="GameEngine.backToMap()">è¿”å›åœ°åœ–</button>
            </div>
        </div>

        <!-- çå‹µéŠæˆ²ç•«é¢ -->
        <div id="bonusScreen" class="game-screen">
            <div class="game-header">
                <div class="game-info">
                    <div class="info-item">æ˜Ÿæ˜Ÿæ”¶é›†å¤§ä½œæˆ°</div>
                    <div class="info-item">å¾—åˆ†: <span id="bonusScore">0</span></div>
                </div>
                <button class="back-btn" onclick="BonusGame.stop()">çµæŸéŠæˆ²</button>
            </div>
            <div id="bonusGameContainer" style="position: relative; width: 100%; height: 400px; background: linear-gradient(to bottom, #1a2a6c, #b21f1f, #fdbb2d); overflow: hidden; border-radius: 15px; cursor: crosshair;">
                <!-- éŠæˆ²å…ƒç´ å°‡ç”± JS å‹•æ…‹ç”Ÿæˆ -->
            </div>
            <p style="text-align: center; margin-top: 10px; color: #666;">ç§»å‹•ç±ƒå­æ¥ä½æ‰è½çš„æ˜Ÿæ˜Ÿå§ï¼</p>
        </div>

        <!-- æ¶ˆæ¶ˆæ¨‚éŠæˆ²ç•«é¢ -->
        <div id="match3Screen" class="game-screen">
            <div class="game-header">
                <div class="game-info">
                    <div class="info-item">æ£®æ—æ¶ˆæ¶ˆæ¨‚</div>
                    <div class="info-item">å¾—åˆ†: <span id="match3Score">0</span></div>
                </div>
                <button class="back-btn" onclick="Match3Game.stop()">è¿”å›åœ°åœ–</button>
            </div>
            <div id="match3Container" class="match3-container">
                <!-- ç¶²æ ¼å°‡ç”± JS å‹•æ…‹ç”Ÿæˆ -->
            </div>
            <p style="text-align: center; margin-top: 10px; color: #666;">é»æ“Šå…©å€‹ç›¸é„°çš„æ°´æœä¾†äº¤æ›ä½ç½®ï¼</p>
        </div>

        <!-- å°„æ“ŠéŠæˆ²ç•«é¢ -->
        <div id="shooterScreen" class="game-screen">
            <div class="game-header">
                <div class="game-info">
                    <div class="info-item">æ£®æ—å°„æ“Šæˆ°</div>
                    <div class="info-item">å¾—åˆ†: <span id="shooterScore">0</span></div>
                </div>
                <button class="back-btn" onclick="ShootingGame.stop()">è¿”å›åœ°åœ–</button>
            </div>
            <div id="shooterContainer" class="shooter-container">
                <div class="shooter-hud">W/A/S/D æˆ–æ‹–æ›³ç§»å‹•ï¼Œé»æ“Š/ç©ºç™½éµå°„æ“Š</div>
            </div>
            <p style="text-align:center; margin-top:10px; color:#666;">æ¶ˆæ»…æ£®æ—ä¸­çš„æ—è›‹å¹½éˆå§ï¼</p>
        </div>

        <!-- è¨˜æ†¶éŠæˆ²ç•«é¢ -->
        <div id="memoryScreen" class="game-screen">
            <div class="game-header">
                <div class="game-info">
                    <div class="info-item">æ£®æ—è¨˜æ†¶ç‹</div>
                    <div class="info-item">é…å°: <span id="memoryPairs">0</span>/12</div>
                </div>
                <button class="back-btn" onclick="MemoryGame.stop()">è¿”å›åœ°åœ–</button>
            </div>
            <div id="memoryGrid" class="memory-grid">
                <!-- å¡ç‰‡å°‡ç”± JS å‹•æ…‹ç”Ÿæˆ -->
            </div>
            <p style="text-align: center; margin-top: 10px; color: #666;">æ‰¾å‡ºå…©å…©æˆå°çš„å¡ç‰‡å§ï¼</p>
        </div>
    </div>

    <script>
        // çå‹µå°éŠæˆ²é‚è¼¯
        const BonusGame = {
            score: 0,
            gameActive: false,
            stars: [],
            basketPos: 50,
            animationId: null,
            spawnTimer: null,

            start(bypassUnlock = false) {
                const unlocked = bypassUnlock || UIManager.hasThreeStars();
                if (!unlocked) {
                    alert(`ğŸŒŸ åœ¨ä»»ä¸€é—œå¡ç²å¾— 3 é¡†æ˜Ÿæ˜Ÿå³å¯è§£é–çå‹µéŠæˆ²å–”ï¼ç¹¼çºŒåŠ æ²¹ï¼`);
                    return;
                }

                this.score = 0;
                this.gameActive = true;
                this.stars = [];
                this.basketPos = 50;
                
                UIManager.showScreen('bonus');
                this.initUI();
                this.gameLoop();
                this.spawnStar();
            },

            stop() {
                this.gameActive = false;
                cancelAnimationFrame(this.animationId);
                clearTimeout(this.spawnTimer);
                UIManager.showScreen('map');
            },

            winGame() {
                if (!this.gameActive) return;
                this.gameActive = false;
                cancelAnimationFrame(this.animationId);
                clearTimeout(this.spawnTimer);
                
                // æ’­æ”¾å‹åˆ©éŸ³æ•ˆ
                AudioSystem.playComplete();
                
                // æ¸…ç†å‰©é¤˜æ˜Ÿæ˜Ÿ
                const container = document.getElementById('bonusGameContainer');
                if (container) {
                    const stars = container.querySelectorAll('.falling-star');
                    stars.forEach(s => s.remove());
                    
                    // å»ºç«‹éé—œç•«é¢å±¤
                    const winOverlay = document.createElement('div');
                    winOverlay.id = 'winOverlay';
                    winOverlay.style.cssText = `
                        position: absolute;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: rgba(0, 0, 0, 0.8);
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                        justify-content: center;
                        color: white;
                        z-index: 200;
                        animation: modalSlideIn 0.5s ease;
                        text-align: center;
                        padding: 20px;
                    `;
                    
                    winOverlay.innerHTML = `
                        <h2 style="font-size: clamp(28px, 6vw, 40px); color: #ffd700; margin-bottom: 15px; text-shadow: 0 0 10px rgba(255,215,0,0.5);">ğŸŠ æ­å–œéé—œ ğŸŠ</h2>
                        <div style="font-size: 60px; margin-bottom: 15px;">â­â­â­</div>
                        <p style="font-size: clamp(18px, 4vw, 22px); margin-bottom: 25px;">å¤ªå²å®³äº†ï¼ä½ æ”¶é›†æ»¿ 100 åˆ†äº†ï¼<br>ä½ æ˜¯çœŸæ­£çš„æ˜Ÿæ˜Ÿæ”¶é›†å¤§å¸«ï¼</p>
                        <button class="result-btn home-btn" style="min-width: 200px;" onclick="BonusGame.stop()">è¿”å›åœ°åœ–</button>
                    `;
                    container.appendChild(winOverlay);
                }
            },

            initUI() {
                const container = document.getElementById('bonusGameContainer');
                container.innerHTML = `
                    <div id="basket" style="position: absolute; bottom: 10px; left: 50%; width: 80px; height: 50px; transform: translateX(-50%); transition: left 0.05s linear; cursor: pointer;">ğŸ§º</div>
                `;
                document.getElementById('bonusScore').textContent = '0';

                const handleMove = (e) => {
                    if (!this.gameActive) return;
                    const rect = container.getBoundingClientRect();
                    let clientX;
                    if (e.touches && e.touches.length > 0) {
                        clientX = e.touches[0].clientX;
                    } else {
                        clientX = e.clientX;
                    }
                    const x = clientX - rect.left;
                    this.basketPos = Math.max(5, Math.min(95, (x / rect.width) * 100));
                    const basket = document.getElementById('basket');
                    if (basket) basket.style.left = this.basketPos + '%';
                };

                container.onmousemove = handleMove;
                container.ontouchmove = (e) => {
                    handleMove(e);
                    if (e.cancelable) e.preventDefault();
                };
            },

            spawnStar() {
                if (!this.gameActive) return;
                
                const id = Date.now() + Math.random();
                const rand = Math.random();
                
                // å®šç¾©ä¸åŒé¡å‹çš„æ‰è½ç‰©
                // é»ƒè‰²æ˜Ÿæ˜Ÿ: 70%, ç´…è‰²æ˜Ÿæ˜Ÿ: 15%, å½©è‰²æ˜Ÿæ˜Ÿ: 5%, ç‚¸å½ˆ: 10%
                let typeConfig = { 
                    icon: 'â˜…', 
                    score: 1, 
                    style: 'color: #ffd700; filter: drop-shadow(0 0 2px rgba(0,0,0,0.5));' 
                };

                if (rand < 0.05) { // å½©è‰²æ˜Ÿæ˜Ÿ (3åˆ†)
                    typeConfig = { 
                        icon: 'â˜…', 
                        score: 3, 
                        style: 'color: #ff00ea; animation: rainbowStar 0.8s linear infinite;' 
                    };
                } else if (rand < 0.20) { // ç´…è‰²æ˜Ÿæ˜Ÿ (2åˆ†)
                    typeConfig = { 
                        icon: 'â˜…', 
                        score: 2, 
                        style: 'color: #ff0000; filter: drop-shadow(0 0 3px rgba(255,255,255,0.8));' 
                    };
                } else if (rand < 0.30) { // ç‚¸å½ˆ (-1åˆ†)
                    typeConfig = { 
                        icon: 'ğŸ’£', 
                        score: -1, 
                        style: '' 
                    };
                }

                const star = {
                    id: id,
                    x: Math.random() * 90 + 5,
                    y: -40,
                    speed: Math.random() * 3 + 2,
                    score: typeConfig.score
                };
                this.stars.push(star);
                
                const starEl = document.createElement('div');
                starEl.id = `star-${id}`;
                starEl.className = 'falling-star';
                starEl.style.position = 'absolute';
                starEl.style.left = star.x + '%';
                starEl.style.top = star.y + 'px';
                starEl.innerHTML = `<span style="${typeConfig.style}">${typeConfig.icon}</span>`;
                starEl.style.fontSize = '35px';
                document.getElementById('bonusGameContainer').appendChild(starEl);

                this.spawnTimer = setTimeout(() => this.spawnStar(), 800);
            },

            gameLoop() {
                if (!this.gameActive) return;

                const container = document.getElementById('bonusGameContainer');
                if (!container) {
                    this.stop();
                    return;
                }
                const containerHeight = container.offsetHeight || 400;

                for (let i = this.stars.length - 1; i >= 0; i--) {
                    const star = this.stars[i];
                    star.y += star.speed;
                    
                    const starEl = document.getElementById(`star-${star.id}`);
                    if (starEl) {
                        starEl.style.top = star.y + 'px';

                        // ç¢°æ’æª¢æ¸¬
                        if (star.y > containerHeight - 80 && star.y < containerHeight - 30) {
                            if (Math.abs(star.x - this.basketPos) < 10) {
                                this.score += star.score;
                                if (this.score < 0) this.score = 0; // åˆ†æ•¸ä¸ä½æ–¼ 0
                                
                                const scoreEl = document.getElementById('bonusScore');
                                if (scoreEl) scoreEl.textContent = this.score;
                                this.createCatchEffect(star.x, star.y, star.score);
                                starEl.remove();
                                this.stars.splice(i, 1);
                                
                                if (star.score > 0) {
                                    AudioSystem.playCorrect();
                                    const basket = document.getElementById('basket');
                                    if (basket) {
                                        basket.style.filter = 'brightness(1.2) drop-shadow(0 0 10px #ffd700)';
                                        setTimeout(() => { if (basket && basket.style) basket.style.filter = ''; }, 200);
                                    }

                                    // æª¢æŸ¥æ˜¯å¦é”åˆ° 100 åˆ†
                                    if (this.score >= 100) {
                                        setTimeout(() => this.winGame(), 200);
                                        return;
                                    }
                                } else {
                                    AudioSystem.playWrong();
                                    const basket = document.getElementById('basket');
                                    if (basket) {
                                        basket.style.filter = 'brightness(1.5) drop-shadow(0 0 10px #ff0000)';
                                        setTimeout(() => { if (basket && basket.style) basket.style.filter = ''; }, 300);
                                    }
                                }
                                continue;
                            }
                        }

                        if (star.y > containerHeight) {
                            starEl.remove();
                            this.stars.splice(i, 1);
                        }
                    } else {
                        // å¦‚æœå…ƒç´ æ¶ˆå¤±äº†ä½†è³‡æ–™é‚„åœ¨ï¼Œä¹Ÿæ¸…ç†æ‰
                        this.stars.splice(i, 1);
                    }
                }

                this.animationId = requestAnimationFrame(() => this.gameLoop());
            },

            createCatchEffect(x, y, score) {
                const container = document.getElementById('bonusGameContainer');
                if (!container) return;

                // åˆ†æ•¸æµ®å‹•æ–‡å­—
                const effect = document.createElement('div');
                effect.className = 'score-effect';
                effect.style.left = x + '%';
                effect.style.top = y + 'px';
                effect.style.transform = 'translateX(-50%)';
                
                if (score > 0) {
                    effect.textContent = `+${score}`;
                    effect.style.color = '#ffff00';
                } else {
                    effect.innerHTML = 'ğŸ’¥ -1';
                    effect.style.color = '#ff4d4d';
                    effect.style.fontSize = '32px';
                }
                
                container.appendChild(effect);
                
                // æ“´æ•£æ¼£æ¼ªæ•ˆæœ
                const ripple = document.createElement('div');
                ripple.className = 'catch-ripple';
                ripple.style.left = x + '%';
                ripple.style.top = y + 'px';
                if (score < 0) {
                    ripple.style.borderColor = '#ff0000';
                    ripple.style.borderWidth = '4px';
                }
                container.appendChild(ripple);

                // è‡ªå‹•æ¸…ç†
                setTimeout(() => {
                    if (effect.parentNode) effect.remove();
                    if (ripple.parentNode) ripple.remove();
                }, 1000);
            }
        };

        // ç®¡ç†è€…å¯†ç¢¼é©—è­‰ï¼ˆæ”¹ç‚ºè‡ªè¨‚å½ˆçª—ï¼Œè¼¸å…¥å…§å®¹éš±è—ï¼‰
        const SecureBonus = {
            promptAndStart() {
                // é–‹å•Ÿè‡ªè¨‚å¯†ç¢¼å½ˆçª—
                const modal = document.getElementById('adminPasswordModal');
                const input = document.getElementById('adminPasswordInput');
                const error = document.getElementById('adminPasswordError');
                if (error) error.style.display = 'none';
                if (input) {
                    input.value = '';
                    modal.classList.add('active');
                    setTimeout(() => input.focus(), 50);
                    input.onkeydown = (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            this.submitPassword();
                        } else if (e.key === 'Escape') {
                            e.preventDefault();
                            this.closeModal();
                        }
                    };
                }
            },
            getTodayPassword() {
                const today = new Date();
                const yyyy = String(today.getFullYear());
                const mm = String(today.getMonth() + 1).padStart(2, '0');
                const dd = String(today.getDate()).padStart(2, '0');
                return `${yyyy}${mm}${dd}`;
            },
            submitPassword() {
                try {
                    const input = document.getElementById('adminPasswordInput');
                    const error = document.getElementById('adminPasswordError');
                    const value = (input.value || '').trim();
                    const password = this.getTodayPassword();
                    if (value === password) {
                        this.closeModal();
                        UIManager.openAdminModal();
                    } else {
                        if (error) error.style.display = 'block';
                        input.focus();
                        input.select && input.select();
                    }
                } catch (e) {
                    console.error('Password submit error:', e);
                    alert('å‡ºç¾å•é¡Œï¼Œè«‹ç¨å¾Œå†è©¦ã€‚');
                }
            },
            closeModal() {
                const modal = document.getElementById('adminPasswordModal');
                if (modal) modal.classList.remove('active');
            }
        };

        // æ¶ˆæ¶ˆæ¨‚éŠæˆ²é‚è¼¯
        const Match3Game = {
            gridSize: 8,
            items: ['ğŸ', 'ğŸ‡', 'ğŸŠ', 'ğŸ“', 'ğŸ¥', 'ğŸ‹'],
            grid: [],
            score: 0,
            selectedTile: null,
            isProcessing: false,

            start(bypass = false) {
                if (!bypass) {
                    const available = UIManager.getAvailableStars();
                    if (available < 3) {
                        alert(`ğŸŒŸ éœ€è¦ 3 é¡†å¯ç”¨æ˜Ÿæ˜Ÿæ‰èƒ½ç©ã€Œæ£®æ—æ¶ˆæ¶ˆæ¨‚ã€å–”ï¼\nè¶•å¿«å»æŒ‘æˆ°é—œå¡è³ºå–æ˜Ÿæ˜Ÿå§ï¼`);
                        return;
                    }

                    if (!confirm(`ç¢ºå®šè¦èŠ±è²» 3 é¡†æ˜Ÿæ˜Ÿé–‹å§‹ã€Œæ£®æ—æ¶ˆæ¶ˆæ¨‚ã€å—ï¼Ÿ`)) {
                        return;
                    }
                    if (!Storage.consumeStarsSequentially(3)) {
                        return;
                    }
                    UIManager.renderLevelMap();
                }

                this.score = 0;
                this.isProcessing = false;
                this.selectedTile = null;
                UIManager.showScreen('match3');
                this.initGrid();
                this.renderGrid();
                document.getElementById('match3Score').textContent = '0';
            },

            stop() {
                UIManager.showScreen('map');
            },

            initGrid() {
                this.grid = [];
                for (let r = 0; r < this.gridSize; r++) {
                    this.grid[r] = [];
                    for (let c = 0; c < this.gridSize; c++) {
                        let item;
                        do {
                            item = this.items[Math.floor(Math.random() * this.items.length)];
                        } while (this.isInitialMatch(r, c, item));
                        this.grid[r][c] = item;
                    }
                }
            },

            isInitialMatch(r, c, item) {
                if (r >= 2 && this.grid[r-1][c] === item && this.grid[r-2][c] === item) return true;
                if (c >= 2 && this.grid[r][c-1] === item && this.grid[r][c-2] === item) return true;
                return false;
            },

            renderGrid() {
                const container = document.getElementById('match3Container');
                container.innerHTML = '';
                for (let r = 0; r < this.gridSize; r++) {
                    for (let c = 0; c < this.gridSize; c++) {
                        const tile = document.createElement('div');
                        tile.className = 'match3-tile';
                        tile.textContent = this.grid[r][c];
                        tile.dataset.row = r;
                        tile.dataset.col = c;
                        tile.onclick = (e) => this.handleTileClick(r, c, tile);
                        container.appendChild(tile);
                    }
                }
            },

            handleTileClick(r, c, tileEl) {
                if (this.isProcessing) return;

                if (!this.selectedTile) {
                    this.selectedTile = { r, c, el: tileEl };
                    tileEl.classList.add('selected');
                } else {
                    const prev = this.selectedTile;
                    const dist = Math.abs(r - prev.r) + Math.abs(c - prev.c);

                    if (dist === 1) {
                        this.swap(prev.r, prev.c, r, c);
                    } else {
                        prev.el.classList.remove('selected');
                        if (prev.r === r && prev.c === c) {
                            this.selectedTile = null;
                        } else {
                            this.selectedTile = { r, c, el: tileEl };
                            tileEl.classList.add('selected');
                        }
                    }
                }
            },

            async swap(r1, c1, r2, c2) {
                this.isProcessing = true;
                const prevEl = this.selectedTile.el;
                const currEl = document.querySelector(`[data-row="${r2}"][data-col="${c2}"]`);
                
                prevEl.classList.remove('selected');
                this.selectedTile = null;

                // äº¤æ›æ•¸æ“š
                const temp = this.grid[r1][c1];
                this.grid[r1][c1] = this.grid[r2][c2];
                this.grid[r2][c2] = temp;

                // æ›´æ–° UI
                prevEl.textContent = this.grid[r1][c1];
                currEl.textContent = this.grid[r2][c2];

                const matches = this.findMatches();
                if (matches.length > 0) {
                    await this.processMatches();
                } else {
                    // æ²’åŒ¹é…ï¼Œæ›å›ä¾†
                    await new Promise(resolve => setTimeout(resolve, 300));
                    const tempBack = this.grid[r1][c1];
                    this.grid[r1][c1] = this.grid[r2][c2];
                    this.grid[r2][c2] = tempBack;
                    prevEl.textContent = this.grid[r1][c1];
                    currEl.textContent = this.grid[r2][c2];
                    this.isProcessing = false;
                }
            },

            findMatches() {
                const matches = [];
                // æ°´å¹³
                for (let r = 0; r < this.gridSize; r++) {
                    for (let c = 0; c < this.gridSize - 2; c++) {
                        const item = this.grid[r][c];
                        if (item && item === this.grid[r][c+1] && item === this.grid[r][c+2]) {
                            matches.push({r, c}, {r, c: c+1}, {r, c: c+2});
                        }
                    }
                }
                // å‚ç›´
                for (let c = 0; c < this.gridSize; c++) {
                    for (let r = 0; r < this.gridSize - 2; r++) {
                        const item = this.grid[r][c];
                        if (item && item === this.grid[r+1][c] && item === this.grid[r+2][c]) {
                            matches.push({r, c}, {r: r+1, c}, {r: r+2, c});
                        }
                    }
                }
                // å»é‡
                return Array.from(new Set(matches.map(m => `${m.r},${m.c}`)))
                            .map(s => { const [r, c] = s.split(',').map(Number); return {r, c}; });
            },

            async processMatches() {
                const matches = this.findMatches();
                if (matches.length === 0) {
                    this.isProcessing = false;
                    return;
                }

                // æ¨™è¨˜ä¸¦å‹•ç•«æ¶ˆé™¤
                matches.forEach(m => {
                    const el = document.querySelector(`[data-row="${m.r}"][data-col="${m.c}"]`);
                    if (el) el.classList.add('match');
                });

                AudioSystem.playCorrect();
                this.score += matches.length * 10;
                document.getElementById('match3Score').textContent = this.score;

                await new Promise(resolve => setTimeout(resolve, 400));

                // ç§»é™¤æ•¸æ“š
                matches.forEach(m => {
                    this.grid[m.r][m.c] = null;
                });

                // æ‰è½
                this.dropItems();
                this.renderGrid();

                await new Promise(resolve => setTimeout(resolve, 300));
                await this.processMatches(); // éè¿´æª¢æŸ¥é€£é–åæ‡‰
            },

            dropItems() {
                for (let c = 0; c < this.gridSize; c++) {
                    let emptyRow = this.gridSize - 1;
                    for (let r = this.gridSize - 1; r >= 0; r--) {
                        if (this.grid[r][c] !== null) {
                            this.grid[emptyRow][c] = this.grid[r][c];
                            if (emptyRow !== r) this.grid[r][c] = null;
                            emptyRow--;
                        }
                    }
                    // è£œæ–°æ–¹å¡Š
                    for (let r = emptyRow; r >= 0; r--) {
                        this.grid[r][c] = this.items[Math.floor(Math.random() * this.items.length)];
                    }
                }
            }
        };

        // è¨˜æ†¶éŠæˆ²é‚è¼¯
        const ShootingGame = {
            score: 0,
            active: false,
            player: { x: 50, y: 85, speed: 0.6 }, // percent positions
            bullets: [], // {x,y,vy,el}
            enemies: [], // {x,y,vy,el,hp,score}
            lastTime: 0,
            fireCooldown: 0,
            enemyTimer: 0,
            keyState: {},
            rafId: null,
            bypass: true,
            // ä¸åŒåˆ†å€¼çš„æ€ªç‰©ï¼š1/2/3 åˆ†èˆ‡æ‰£ 1 åˆ†
            enemyTypes: [
                { name: 'ghost', icon: 'ğŸ‘»', score: 1, color: '#66e3ff', speedMin: 0.04, speedMax: 0.07 },
                { name: 'bat',   icon: 'ğŸ¦‡', score: 2, color: '#ffd54f', speedMin: 0.05, speedMax: 0.08 },
                { name: 'ogre',  icon: 'ğŸ‘¹', score: 3, color: '#ff5252', speedMin: 0.03, speedMax: 0.05 },
                { name: 'skull', icon: 'ğŸ’€', score: -1, color: '#ff1744', speedMin: 0.06, speedMax: 0.10 }
            ],
            enemyWeights: [0.5, 0.25, 0.15, 0.10],
            maxEnemies: 14,

            start(bypass = false) {
                this.bypass = bypass;
                // No star cost; admin access only for now
                this.reset();
                UIManager.showScreen('shooter');
                this.initUI();
                this.bindControls();
                this.active = true;
                this.lastTime = performance.now();
                this.rafId = requestAnimationFrame((t) => this.loop(t));
            },

            stop() {
                this.active = false;
                cancelAnimationFrame(this.rafId);
                this.unbindControls();
                this.clearEntities();
                UIManager.showScreen('map');
            },

            reset() {
                this.score = 0;
                this.player = { x: 50, y: 85, speed: 0.6 };
                this.bullets = [];
                this.enemies = [];
                this.fireCooldown = 0;
                this.enemyTimer = 0;
                const scoreEl = document.getElementById('shooterScore');
                if (scoreEl) scoreEl.textContent = '0';
            },

            initUI() {
                const c = document.getElementById('shooterContainer');
                if (!c) return;
                c.innerHTML = '';
                // player element
                const p = document.createElement('div');
                p.id = 'shooterPlayer';
                p.className = 'shooter-player';
                p.textContent = 'ğŸ¹';
                c.appendChild(p);
                this.updatePlayerEl();
                // åˆ†æ•¸åœ–ç¤ºèªªæ˜ï¼ˆå³ä¸Šè§’ï¼‰
                const legend = document.createElement('div');
                legend.className = 'shooter-legend';
                legend.innerHTML = `
                    <div class="legend-row"><span class="icon" style="color:#66e3ff;">ğŸ‘»</span><span class="text">+1 åˆ†</span></div>
                    <div class="legend-row"><span class="icon" style="color:#ffd54f;">ğŸ¦‡</span><span class="text">+2 åˆ†ï¼ˆéœ€å°„ 2 æ¬¡ï¼‰</span></div>
                    <div class="legend-row"><span class="icon" style="color:#ff5252;">ğŸ‘¹</span><span class="text">+3 åˆ†ï¼ˆéœ€å°„ 3 æ¬¡ï¼‰</span></div>
                    <div class="legend-row"><span class="icon" style="color:#ff1744;">ğŸ’€</span><span class="text">-1 åˆ†</span></div>
                `;
                c.appendChild(legend);
                // Touch/mouse move support
                const moveTo = (clientX, clientY) => {
                    const rect = c.getBoundingClientRect();
                    const x = Math.max(0, Math.min(100, ((clientX - rect.left) / rect.width) * 100));
                    const y = Math.max(0, Math.min(100, ((clientY - rect.top) / rect.height) * 100));
                    this.player.x = x;
                    this.player.y = y;
                    this.updatePlayerEl();
                };
                c.onpointerdown = (e) => { moveTo(e.clientX, e.clientY); this.tryFire(); };
                c.onpointermove = (e) => { if (e.buttons) moveTo(e.clientX, e.clientY); };
            },

            bindControls() {
                this.keyState = {};
                this._keyDown = (e) => {
                    this.keyState[e.key.toLowerCase()] = true;
                    if (e.code === 'Space') { e.preventDefault(); this.tryFire(); }
                };
                this._keyUp = (e) => { this.keyState[e.key.toLowerCase()] = false; };
                window.addEventListener('keydown', this._keyDown);
                window.addEventListener('keyup', this._keyUp);
            },
            unbindControls() {
                window.removeEventListener('keydown', this._keyDown);
                window.removeEventListener('keyup', this._keyUp);
            },

            updatePlayerEl() {
                const p = document.getElementById('shooterPlayer');
                if (p) {
                    p.style.left = this.player.x + '%';
                    p.style.top = this.player.y + '%';
                }
            },

            tryFire() {
                if (this.fireCooldown > 0 || !this.active) return;
                this.fireCooldown = 180; // ms
                this.spawnBullet(this.player.x, this.player.y - 6);
                AudioSystem.playCorrect();
            },

            spawnBullet(x, y) {
                const c = document.getElementById('shooterContainer');
                if (!c) return;
                const el = document.createElement('div');
                el.className = 'shooter-bullet';
                el.style.left = x + '%';
                el.style.top = y + '%';
                c.appendChild(el);
                this.bullets.push({ x, y, vy: -0.35, el });
            },

            spawnEnemy() {
                const c = document.getElementById('shooterContainer');
                if (!c) return;
                // æ±ºå®šé€™ä¸€è¼ªè¦ç”Ÿå¹¾éš»
                let toSpawn = Math.random() < 0.35 ? 2 : 1;
                while (toSpawn-- > 0 && this.enemies.length < this.maxEnemies) {
                    // ä¾æ¬Šé‡é¸å‹
                    const r = Math.random();
                    let acc = 0;
                    let type = this.enemyTypes[0];
                    for (let i = 0; i < this.enemyTypes.length; i++) {
                        acc += this.enemyWeights[i] || 0;
                        if (r <= acc) { type = this.enemyTypes[i]; break; }
                    }
                    const el = document.createElement('div');
                    el.className = 'shooter-enemy';
                    el.textContent = type.icon;
                    const x = 5 + Math.random() * 90;
                    const y = -5 - Math.random() * 5;
                    el.style.left = x + '%';
                    el.style.top = y + '%';
                    // ä¸åŒé¡å‹ç¨å¾®ä¸åŒçš„ç™¼å…‰é¡è‰²
                    el.style.filter = `drop-shadow(0 0 10px ${type.color})`;
                    // 3 åˆ†æ€ªï¼ˆogreï¼‰æ›´å¤§ä¸”æ›´äº®
                    if (type.name === 'ogre') {
                        el.style.width = '72px';
                        el.style.height = '72px';
                        el.style.fontSize = '64px';
                        el.style.filter = `drop-shadow(0 0 14px ${type.color}) saturate(1.2)`;
                        el.classList.add('ogre-boss');
                    }
                    c.appendChild(el);
                    const speed = type.speedMin + Math.random() * (type.speedMax - type.speedMin);
                    const hp = type.score > 0 ? type.score : 1; // 2åˆ†è¦å°„2æ¬¡ï¼Œ3åˆ†è¦å°„3æ¬¡ï¼Œå…¶é¤˜1æ¬¡
                    this.enemies.push({ x, y, vy: speed, el, hp, score: type.score });
                }
            },

            explosion(x, y, color = '#ffd700') {
                const c = document.getElementById('shooterContainer');
                if (!c) return;
                const el = document.createElement('div');
                el.className = 'shooter-explosion';
                el.style.left = x + '%';
                el.style.top = y + '%';
                el.style.borderColor = color;
                c.appendChild(el);
                requestAnimationFrame(() => {
                    el.style.transform = 'translate(-50%, -50%) scale(1.6)';
                    el.style.opacity = '0';
                });
                setTimeout(() => el.remove(), 280);
            },

            clearEntities() {
                const c = document.getElementById('shooterContainer');
                if (!c) return;
                [...c.querySelectorAll('.shooter-bullet,.shooter-enemy,.shooter-explosion')].forEach(n => n.remove());
            },

            loop(timestamp) {
                if (!this.active) return;
                const dt = Math.min(50, timestamp - this.lastTime);
                this.lastTime = timestamp;
                // cooldown timers
                this.fireCooldown = Math.max(0, this.fireCooldown - dt);
                this.enemyTimer += dt;
                if (this.enemyTimer > 550) { this.enemyTimer = 0; this.spawnEnemy(); }

                // keyboard movement
                const speed = (this.player.speed * dt);
                if (this.keyState['a'] || this.keyState['arrowleft']) this.player.x -= speed;
                if (this.keyState['d'] || this.keyState['arrowright']) this.player.x += speed;
                if (this.keyState['w'] || this.keyState['arrowup']) this.player.y -= speed;
                if (this.keyState['s'] || this.keyState['arrowdown']) this.player.y += speed;
                this.player.x = Math.max(5, Math.min(95, this.player.x));
                this.player.y = Math.max(10, Math.min(95, this.player.y));
                this.updatePlayerEl();

                // update bullets
                for (let i = this.bullets.length - 1; i >= 0; i--) {
                    const b = this.bullets[i];
                    b.y += b.vy * (dt);
                    if (b.el) b.el.style.top = b.y + '%';
                    if (b.y < -5) { b.el && b.el.remove(); this.bullets.splice(i, 1); }
                }
                // update enemies
                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    const e = this.enemies[i];
                    e.y += e.vy * (dt);
                    if (e.el) e.el.style.top = e.y + '%';
                    // check reach bottom -> penalty
                    if (e.y > 105) {
                        // æ‰è½åˆ°åº•éƒ¨ä¸æ‰£åˆ†ï¼Œç›´æ¥ç§»é™¤
                        e.el && e.el.remove();
                        this.enemies.splice(i, 1);
                    }
                }
                // collisions bullet-enemy
                for (let bi = this.bullets.length - 1; bi >= 0; bi--) {
                    const b = this.bullets[bi];
                    for (let ei = this.enemies.length - 1; ei >= 0; ei--) {
                        const e = this.enemies[ei];
                        const dx = (b.x - e.x);
                        const dy = (b.y - e.y);
                        if (Math.abs(dx) < 5 && Math.abs(dy) < 8) {
                            // hit
                            b.el && b.el.remove();
                            this.bullets.splice(bi, 1);
                            e.hp -= 1;
                            if (e.hp <= 0) {
                                const delta = (typeof e.score === 'number') ? e.score : 1;
                                const positive = delta > 0;
                                this.explosion(e.x, e.y, positive ? '#ffd700' : '#ff1744');
                                e.el && e.el.remove();
                                this.enemies.splice(ei, 1);
                                if (positive) {
                                    this.score += delta;
                                    AudioSystem.playCorrect();
                                } else {
                                    this.score = Math.max(0, this.score + delta); // delta ç‚ºè² 
                                    AudioSystem.playWrong();
                                }
                                const se = document.getElementById('shooterScore');
                                if (se) se.textContent = String(this.score);
                            }
                            break;
                        }
                    }
                }

                // simple win condition
                if (this.score >= 100) {
                    this.showWin();
                    return;
                }

                this.rafId = requestAnimationFrame((t) => this.loop(t));
            },

            showWin() {
                this.active = false;
                cancelAnimationFrame(this.rafId);
                const c = document.getElementById('shooterContainer');
                if (!c) return;
                this.clearEntities();
                const overlay = document.createElement('div');
                overlay.style.cssText = 'position:absolute;inset:0;background:rgba(0,0,0,0.75);display:flex;flex-direction:column;align-items:center;justify-content:center;color:#fff;z-index:10;';
                overlay.innerHTML = '<h2 style="color:#ffd700;margin:8px 0;">ğŸ‰ æ­å–œéé—œï¼</h2><p style="margin:6px 0;">ä½ æ“Šæ•—äº†æ£®æ—å¹½éˆï¼</p>';
                const btn = document.createElement('button');
                btn.className = 'result-btn home-btn';
                btn.textContent = 'è¿”å›åœ°åœ–';
                btn.onclick = () => { this.stop(); };
                overlay.appendChild(btn);
                c.appendChild(overlay);
                AudioSystem.playComplete();
            }
        };

        const MemoryGame = {
            icons: ['ğŸ¦Š', 'ğŸ°', 'ğŸ¦‰', 'ğŸ»', 'ğŸ¦Œ', 'ğŸ—', 'ğŸ¦', 'ğŸ¹', 'ğŸ¿ï¸', 'ğŸ¢', 'ğŸ¦‹', 'ğŸ'],
            cards: [],
            flippedCards: [],
            matchedPairs: 0,
            isProcessing: false,

            start(bypass = false) {
                if (!bypass) {
                    const available = UIManager.getAvailableStars();
                    if (available < 3) {
                        alert(`ğŸŒŸ éœ€è¦ 3 é¡†å¯ç”¨æ˜Ÿæ˜Ÿæ‰èƒ½ç©ã€Œæ£®æ—è¨˜æ†¶ç‹ã€å–”ï¼\nè¶•å¿«å»æŒ‘æˆ°é—œå¡è³ºå–æ˜Ÿæ˜Ÿå§ï¼`);
                        return;
                    }
                    if (!confirm(`ç¢ºå®šè¦èŠ±è²» 3 é¡†æ˜Ÿæ˜Ÿé–‹å§‹ã€Œæ£®æ—è¨˜æ†¶ç‹ã€å—ï¼Ÿ`)) {
                        return;
                    }
                    if (!Storage.consumeStarsSequentially(3)) {
                        return;
                    }
                    UIManager.renderLevelMap();
                }
                this.initGame();
                UIManager.showScreen('memory');
            },

            stop() {
                UIManager.showScreen('map');
            },

            initGame() {
                this.matchedPairs = 0;
                this.flippedCards = [];
                this.isProcessing = false;
                
                // æ¸…ç†å¯èƒ½çš„èˆŠéé—œç•«é¢
                const oldOverlay = document.getElementById('memoryWinOverlay');
                if (oldOverlay) oldOverlay.remove();

                const pairsEl = document.getElementById('memoryPairs');
                if (pairsEl) pairsEl.textContent = '0';
                
                // æº–å‚™ 24 å¼µå¡ç‰‡ (12å°)
                const gameIcons = [...this.icons, ...this.icons];
                const shuffledIcons = Utils.shuffleArray(gameIcons);
                
                this.cards = shuffledIcons.map((icon, index) => ({
                    id: index,
                    icon: icon,
                    isFlipped: false,
                    isMatched: false
                }));
                
                this.renderGrid();
            },

            renderGrid() {
                const grid = document.getElementById('memoryGrid');
                if (!grid) return;
                grid.innerHTML = '';
                this.cards.forEach(card => {
                    const cardEl = document.createElement('div');
                    cardEl.className = 'memory-card';
                    cardEl.dataset.id = card.id;
                    cardEl.innerHTML = `
                        <div class="card-face card-front">${card.icon}</div>
                        <div class="card-face card-back"></div>
                    `;
                    cardEl.onclick = () => this.handleCardClick(card.id, cardEl);
                    grid.appendChild(cardEl);
                });
            },

            handleCardClick(id, el) {
                const card = this.cards[id];
                if (this.isProcessing || card.isFlipped || card.isMatched || this.flippedCards.length >= 2) return;
                
                // ç¿»é–‹å¡ç‰‡
                card.isFlipped = true;
                el.classList.add('flipped');
                this.flippedCards.push({ card, el });
                
                if (this.flippedCards.length === 2) {
                    this.isProcessing = true;
                    setTimeout(() => this.checkMatch(), 600);
                }
            },

            checkMatch() {
                const [c1, c2] = this.flippedCards;
                if (c1.card.icon === c2.card.icon) {
                    // åŒ¹é…æˆåŠŸ
                    c1.card.isMatched = true;
                    c2.card.isMatched = true;
                    
                    // å…ˆåŠ ä¸Šä¸€å€‹çŸ­æš«çš„æˆåŠŸé¡åˆ¥ä¾†è§¸ç™¼å‹•ç•«
                    c1.el.classList.add('matched');
                    c2.el.classList.add('matched');
                    
                    this.matchedPairs++;
                    const pairsEl = document.getElementById('memoryPairs');
                    if (pairsEl) pairsEl.textContent = this.matchedPairs;
                    AudioSystem.playCorrect();
                    
                    if (this.matchedPairs === 12) {
                        setTimeout(() => this.winGame(), 800);
                    }
                } else {
                    // åŒ¹é…å¤±æ•—
                    c1.card.isFlipped = false;
                    c2.card.isFlipped = false;
                    c1.el.classList.remove('flipped');
                    c2.el.classList.remove('flipped');
                    AudioSystem.playWrong();
                }
                
                this.flippedCards = [];
                this.isProcessing = false;
            },

            winGame() {
                AudioSystem.playComplete();
                
                const container = document.getElementById('memoryScreen');
                const winOverlay = document.createElement('div');
                winOverlay.id = 'memoryWinOverlay';
                winOverlay.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.85);
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: center;
                    color: white;
                    z-index: 200;
                    animation: modalSlideIn 0.5s ease;
                    text-align: center;
                    padding: 20px;
                    border-radius: 25px;
                `;
                
                winOverlay.innerHTML = `
                    <h2 style="font-size: clamp(28px, 6vw, 40px); color: #ffd700; margin-bottom: 15px; text-shadow: 0 0 10px rgba(255,215,0,0.5);">ğŸŠ è¨˜æ†¶å¤§å¸« ğŸŠ</h2>
                    <div style="font-size: 60px; margin-bottom: 15px;">ğŸŒŸğŸŒŸğŸŒŸ</div>
                    <p style="font-size: clamp(18px, 4vw, 22px); margin-bottom: 25px;">å¤ªå¼·äº†ï¼ä½ æ‰¾å‡ºäº†æ‰€æœ‰æ£®æ—å¤¥ä¼´ï¼<br>ä½ çš„è¨˜æ†¶åŠ›çœŸæ˜¯ä»¤äººé©šå˜†ï¼</p>
                    <button class="result-btn home-btn" style="min-width: 200px;" onclick="MemoryGame.stop()">è¿”å›åœ°åœ–</button>
                `;
                container.appendChild(winOverlay);
                
                const originalStop = this.stop;
                this.stop = () => {
                    winOverlay.remove();
                    originalStop.call(this);
                    this.stop = originalStop; // é‚„åŸ
                };
            }
        };

        const STORY_MAZE_HARD_QUESTIONS = [
            { q: "å°å…‰æœ‰38å¡Šç©æœ¨ï¼Œå°è¯çµ¦ä»–16å¡Šå¾Œï¼Œå°å…‰åˆå€Ÿçµ¦åŒå­¸15å¡Šï¼Œå°å…‰ç¾åœ¨æœ‰å¹¾å¡Šç©æœ¨ï¼Ÿ", options: ["39å¡Š", "37å¡Š", "22å¡Š", "7å¡Š"], answer: "39å¡Š" },
            { q: "å°å‚‘å®¶è£¡æœ‰24æœ¬æ•…äº‹æ›¸ï¼Œçˆ¸çˆ¸åˆè²·äº†18æœ¬ï¼Œçˆºçˆºä¹Ÿé€ä¾†15æœ¬ï¼Œç¾åœ¨å°å‚‘å®¶ä¸€å…±æœ‰å¹¾æœ¬æ•…äº‹æ›¸ï¼Ÿ", options: ["57æœ¬", "49æœ¬", "42æœ¬", "62æœ¬"], answer: "57æœ¬" },
            { q: "æ•™å®¤è£¡åŸæœ¬æœ‰14æç²‰ç­†ï¼Œç¬¬ä¸€ç¯€èª²å…ˆç”¨5æï¼Œç¬¬äºŒç¯€èª²å†ç”¨4æï¼Œç¾åœ¨é‚„æœ‰å¹¾æç²‰ç­†ï¼Ÿ", options: ["5æ", "13æ", "23æ", "9æ"], answer: "5æ" },
            { q: "æœƒè­°å®¤è£¡æœ‰40å¼µæ¤…å­ï¼Œå…ˆæ¬èµ°18å¼µï¼Œå¾Œä¾†å†æ¬èµ°12å¼µï¼Œæœƒè­°å®¤è£¡é‚„å‰©å¹¾å¼µæ¤…å­ï¼Ÿ", options: ["10å¼µ", "34å¼µ", "46å¼µ", "58å¼µ"], answer: "10å¼µ" },
            { q: "æ¡¶å­è£¡åŸæœ‰7å€‹ç¶ è‰²æµ·æ´‹çƒçƒï¼Œå…ˆæ”¾é€²å»6å€‹ç´…è‰²æµ·æ´‹çƒï¼Œå†æ”¾é€²å»2å€‹é»ƒè‰²æµ·æ´‹çƒï¼Œæ¡¶å­è£¡åˆèµ·ä¾†æœ‰å¹¾å€‹æµ·æ´‹çƒï¼Ÿ", options: ["15å€‹", "11å€‹", "13å€‹", "9å€‹"], answer: "15å€‹" },
            { q: "1ææ¦´æ§¤å†°æ£’æ˜¯46å…ƒï¼Œ1æç´…è±†ç‰›å¥¶å†°æ£’æ¯”æ¦´æ§¤å†°æ£’å°‘19å…ƒï¼Œ1ææœæå†°æ£’æ¯”ç´…è±†ç‰›å¥¶å†°æ£’å°‘9å…ƒï¼Œ1ææœæå†°æ£’æ˜¯å¹¾å…ƒï¼Ÿ", options: ["18å…ƒ", "27å…ƒ", "10å…ƒ", "37å…ƒ"], answer: "18å…ƒ" },
            { q: "æ¸¸æ³³æ± æä¾›20å€‹é»ƒè‰²æµ®æ¿å’Œ10å€‹è—è‰²æµ®æ¿ï¼Œè¢«å€Ÿèµ°15å€‹ï¼Œæ¸¸æ³³æ± é‚„å‰©ä¸‹å¹¾å€‹æµ®æ¿ï¼Ÿ", options: ["15å€‹", "25å€‹", "5å€‹", "10å€‹"], answer: "15å€‹" },
            { q: "åª½åª½è²·äº†60é¡†ç³–æœï¼Œå…ˆåˆ†çµ¦å“¥å“¥18é¡†ï¼Œå†åˆ†çµ¦å¦¹å¦¹25é¡†ï¼Œåª½åª½é‚„å‰©å¹¾é¡†ç³–æœï¼Ÿ", options: ["17é¡†", "19é¡†", "21é¡†", "27é¡†"], answer: "17é¡†" },
            { q: "åª½åª½å»è¶…å¸‚è²·æ±è¥¿ï¼Œå¥¹è²·äº†ä¸€ç½28å…ƒçš„ç‰›å¥¶ã€ä¸€å€‹15å…ƒçš„éºµåŒ…å’Œä¸€ä»½35å…ƒçš„æ²™æ‹‰ï¼Œåª½åª½å…±èŠ±äº†å¤šå°‘å…ƒï¼Ÿ", options: ["78å…ƒ", "68å…ƒ", "88å…ƒ", "73å…ƒ"], answer: "78å…ƒ" },
            { q: "æ›¸æ¶ä¸ŠåŸæœ‰11æœ¬é›œèªŒï¼Œå°è¯å…ˆæ”¾å…¥8æœ¬æ•…äº‹æ›¸ï¼Œå†æ”¾å…¥9æœ¬ç¹ªæœ¬ï¼Œæ›¸æ¶ä¸Šç¾åœ¨å…±æœ‰å¹¾æœ¬æ›¸ï¼Ÿ", options: ["28æœ¬", "29æœ¬", "27æœ¬", "20æœ¬"], answer: "28æœ¬" },
            { q: "å°ç¾åšäº†25å€‹ç™½å·§å…‹åŠ›å’Œ36å€‹é»‘å·§å…‹åŠ›ï¼Œé€çµ¦å°èŠ³19å€‹å¾Œï¼Œé‚„å‰©ä¸‹å¹¾å€‹å·§å…‹åŠ›ï¼Ÿ", options: ["42å€‹", "80å€‹", "30å€‹", "61å€‹"], answer: "42å€‹" },
            { q: "é˜¿æ½­å¸¶60å…ƒå»è¶…å•†è²·äº†18å…ƒçš„èŒ¶è‘‰è›‹å’Œ32å…ƒçš„éºµåŒ…å¾Œï¼Œé‚„å‰©ä¸‹å¹¾å…ƒï¼Ÿ", options: ["10å…ƒ", "46å…ƒ", "42å…ƒ", "28å…ƒ"], answer: "10å…ƒ" },
            { q: "å°ç¾æœ‰26å¼µè²¼ç´™ï¼Œå°èŠ³é€å¥¹18å¼µï¼Œå°è‹±åˆé€å¥¹14å¼µï¼Œå°ç¾ç¾åœ¨å…±æœ‰å¹¾å¼µè²¼ç´™ï¼Ÿ", options: ["58å¼µ", "57å¼µ", "40å¼µ", "44å¼µ"], answer: "58å¼µ" },
            { q: "å°ç¾è²·äº†30å¼µåœ–ç•«ç´™ï¼Œå…ˆé€çµ¦å°æ¬£7å¼µï¼Œå†é€çµ¦å°æ€¡9å¼µï¼Œå°ç¾é‚„å‰©å¹¾å¼µåœ–ç•«ç´™ï¼Ÿ", options: ["14å¼µ", "12å¼µ", "10å¼µ", "23å¼µ"], answer: "14å¼µ" },
            { q: "ç³–æœè¢‹è£¡æœ‰70é¡†ç³–æœï¼Œå°çåƒäº†25é¡†ï¼Œå°ç¾åˆæ”¾å…¥18é¡†ï¼Œç³–æœè¢‹è£¡ç¾åœ¨æœ‰å¹¾é¡†ç³–æœï¼Ÿ", options: ["63é¡†", "52é¡†", "45é¡†", "77é¡†"], answer: "63é¡†" },
            { q: "å°æ˜ä»Šå¤©è¦èƒŒ20å€‹è‹±æ–‡å–®å­—ï¼Œä¸Šåˆå…ˆèƒŒ9å€‹ï¼Œä¸‹åˆå†èƒŒ7å€‹ï¼Œå°æ˜é‚„æœ‰å¹¾å€‹å–®å­—æ²’èƒŒï¼Ÿ", options: ["4å€‹", "18å€‹", "36å€‹", "22å€‹"], answer: "4å€‹" },
            { q: "ç®±å­è£¡æœ‰74åŒ…è¢–çåŒ…é¢ç´™ï¼Œçˆ¸çˆ¸æ‹¿å»35åŒ…å¾Œï¼Œåª½åª½åˆæ”¾å…¥17åŒ…ï¼Œç®±å­è£¡ç¾åœ¨æœ‰å¹¾åŒ…è¢–çåŒ…é¢ç´™ï¼Ÿ", options: ["56åŒ…", "45åŒ…", "39åŒ…", "66åŒ…"], answer: "56åŒ…" },
            { q: "ç­ä¸Šåšå¡ç‰‡ï¼Œç¬¬ä¸€çµ„åšäº†22å¼µï¼Œç¬¬äºŒçµ„åšäº†18å¼µï¼Œç¬¬ä¸‰çµ„åšäº†19å¼µï¼Œä¸€å…±åšäº†å¹¾å¼µå¡ç‰‡ï¼Ÿ", options: ["59å¼µ", "60å¼µ", "69å¼µ", "40å¼µ"], answer: "59å¼µ" },
            { q: "åœ–æ›¸å®¤åŸæœ‰40æœ¬ç«¥æ›¸ï¼Œä¸Šåˆæ­¸é‚„äº†35æœ¬åœ–ç•«æ›¸ï¼Œä¸‹åˆæ­¸é‚„äº†15æœ¬ç™¾ç§‘æ›¸ã€‚ç¾åœ¨åœ–æ›¸å®¤å…±æœ‰å¹¾æœ¬æ›¸ï¼Ÿ", options: ["90æœ¬", "95æœ¬", "100æœ¬", "80æœ¬"], answer: "90æœ¬" },
            { q: "é˜¿é–æ¡äº†22å€‹æŸ³ä¸ï¼Œå°å›æ¯”é˜¿é–å°‘æ¡8å€‹ï¼Œå…©äººå…±æ¡äº†å¹¾å€‹æŸ³ä¸ï¼Ÿ", options: ["36å€‹", "33å€‹", "30å€‹", "38å€‹"], answer: "36å€‹" },
            { q: "å†·è—æ«ƒè£¡æœ‰25ç“¶é®®å¥¶ï¼Œä¸Šåˆè³£å‡º7ç“¶ï¼Œä¸‹åˆåˆè³£å‡º6ç“¶ï¼Œå†·è—æ«ƒè£¡é‚„å‰©å¹¾ç“¶é®®å¥¶ï¼Ÿ", options: ["12ç“¶", "13ç“¶", "18ç“¶", "17ç“¶"], answer: "12ç“¶" },
            { q: "éŠæ¨‚å ´çš„æ—‹è½‰æœ¨é¦¬å¯ä»¥å®¹ç´45å€‹å°æœ‹å‹ï¼Œç¾åœ¨æœ‰20å€‹å°æœ‹å‹åœ¨ä¸Šé¢ï¼Œåˆä¸Šä¾†15å€‹ï¼Œæœ€å¤šé‚„å¯ä»¥å†ä¸Šä¾†å¹¾å€‹å°æœ‹å‹ï¼Ÿ", options: ["5å€‹", "7å€‹", "10å€‹", "15å€‹"], answer: "10å€‹" },
            { q: "åª½åª½è²·äº†13å€‹æŸ³ä¸å’Œ7å€‹è˜‹æœï¼Œå¾Œä¾†åˆåŠ è²·17å€‹å¥‡ç•°æœï¼Œåª½åª½å…±è²·äº†å¹¾å€‹æ°´æœï¼Ÿ", options: ["37å€‹", "35å€‹", "36å€‹", "27å€‹"], answer: "37å€‹" },
            { q: "æ¡¶å­è£¡æœ‰25é¡†ä¹’ä¹“çƒï¼Œå§å§å–å‡º12é¡†ï¼Œå¦¹å¦¹å–å‡º9é¡†ï¼Œæ¡¶å­è£¡é‚„å‰©å¹¾é¡†ä¹’ä¹“çƒï¼Ÿ", options: ["4é¡†", "5é¡†", "6é¡†", "13é¡†"], answer: "4é¡†" },
            { q: "å€‰åº«è£¡æœ‰85ç®±è˜‹æœï¼Œä¸Šåˆå…ˆé‹èµ°30ç®±ï¼Œä¸‹åˆå†é‹èµ°28ç®±ï¼Œå€‰åº«é‚„å‰©å¹¾ç®±è˜‹æœï¼Ÿ", options: ["27ç®±", "143ç®±", "87ç®±", "83ç®±"], answer: "27ç®±" },
            { q: "ç±ƒçƒæ¯”è³½ä¸­ï¼Œå°å¼·ç¬¬ä¸€ç¯€å¾—äº†12åˆ†ï¼Œç¬¬äºŒç¯€å¾—äº†15åˆ†ï¼Œç¬¬ä¸‰ç¯€åˆå¾—äº†8åˆ†ï¼Œä»–å…±å¾—äº†å¹¾åˆ†ï¼Ÿ", options: ["35åˆ†", "36åˆ†", "27åˆ†", "20åˆ†"], answer: "35åˆ†" },
            { q: "å°ç±³åŸæœ‰58å…ƒï¼Œè²·é£²æ–™ç”¨å»30å…ƒï¼Œçˆ¸çˆ¸åˆçµ¦ä»–27å…ƒï¼Œå°ç±³ç¾åœ¨æœ‰å¹¾å…ƒï¼Ÿ", options: ["55å…ƒ", "18å…ƒ", "1å…ƒ", "65å…ƒ"], answer: "55å…ƒ" },
            { q: "ç´…èŒ¶ã€ç¶ èŒ¶å’Œé’èŒ¶å…±65æ¯ï¼Œç´…èŒ¶æœ‰21æ¯ï¼Œé’èŒ¶æœ‰24æ¯ï¼Œç¶ èŒ¶æœ‰å¹¾æ¯ï¼Ÿ", options: ["20æ¯", "15æ¯", "25æ¯", "30æ¯"], answer: "20æ¯" },
            { q: "çƒæ± è£¡æœ‰54å€‹äººï¼Œ25å€‹äººé›¢é–‹å¾Œï¼Œåˆé€²ä¾†16å€‹äººï¼Œçƒæ± è£¡ç¾åœ¨æœ‰å¹¾å€‹äººï¼Ÿ", options: ["45å€‹", "13å€‹", "38å€‹", "95å€‹"], answer: "45å€‹" },
            { q: "æ•™å®¤çš„æ›¸æ¶ä¸Šï¼Œæ•…äº‹æ›¸æœ‰40æœ¬ï¼Œç§‘å­¸æ›¸æœ‰23æœ¬ï¼Œå‹•ç‰©æ›¸æœ‰17æœ¬ï¼Œé€™ä¸‰é¡æ›¸å…±å¹¾æœ¬ï¼Ÿ", options: ["80æœ¬", "79æœ¬", "81æœ¬", "34æœ¬"], answer: "80æœ¬" },
            { q: "æ°´æœåº—æœ‰32å€‹å¥‡ç•°æœï¼Œä¸Šåˆå…ˆè³£äº†13å€‹ï¼Œä¸‹åˆåˆè³£äº†18å€‹ï¼Œæ°´æœåº—é‚„å‰©ä¸‹å¹¾å€‹å¥‡ç•°æœï¼Ÿ", options: ["1å€‹", "37å€‹", "27å€‹", "19å€‹"], answer: "1å€‹" },
            { q: "æ›¸æ¶ä¸Šæœ‰18æœ¬å°èªªå’Œ7æœ¬æ•…äº‹æ›¸ï¼Œç¾è¯å€Ÿèµ°10æœ¬æ›¸å¾Œï¼Œæ›¸æ¶ä¸Šé‚„å‰©ä¸‹å¹¾æœ¬æ›¸ï¼Ÿ", options: ["15æœ¬", "13æœ¬", "17æœ¬", "25æœ¬"], answer: "15æœ¬" },
            { q: "è¨ˆç®—ã€Œ34ï¼‹25ï¼‹16ï¼ï¼Ÿã€ï¼Œæ­£ç¢ºç­”æ¡ˆæ˜¯å¤šå°‘ï¼Ÿ", options: ["75", "65", "85", "70"], answer: "75" },
            { q: "åª½åª½åœ¨ç¬¬ä¸€é–“æ°´æœæ”¤è²·äº†15å€‹å¥‡ç•°æœï¼Œåœ¨ç¬¬äºŒé–“åˆè²·äº†17å€‹ï¼Œå…¨å®¶äººä¸€èµ·åƒæ‰20å€‹å¾Œï¼Œé‚„å‰©å¹¾å€‹å¥‡ç•°æœï¼Ÿ", options: ["12å€‹", "32å€‹", "52å€‹", "22å€‹"], answer: "12å€‹" },
            { q: "ç›’å­è£¡æœ‰20å€‹é›å¡Šï¼Œçˆ¸çˆ¸åƒäº†6å€‹ï¼Œåª½åª½åƒäº†7å€‹ï¼Œç›’å­è£¡é‚„å‰©å¹¾å€‹é›å¡Šï¼Ÿ", options: ["7å€‹", "6å€‹", "19å€‹", "14å€‹"], answer: "7å€‹" },
            { q: "è¨ˆç®—ã€Œ18ï¼‹22ï¼‹30ï¼ï¼Ÿã€ï¼Œæ­£ç¢ºç­”æ¡ˆæ˜¯å¤šå°‘ï¼Ÿ", options: ["70", "60", "80", "72"], answer: "70" },
            { q: "é£²æ–™åº—æº–å‚™äº†30æ¯ç´…èŒ¶ã€25æ¯å¥¶èŒ¶å’Œ20æ¯ç¶ èŒ¶ã€‚ä»Šå¤©ä¸€å…±æº–å‚™äº†å¹¾æ¯é£²æ–™ï¼Ÿ", options: ["75æ¯", "70æ¯", "80æ¯", "65æ¯"], answer: "75æ¯" },
            { q: "å°èŠ¸ä»Šå¤©è¦å¯«45é¡Œä½œæ¥­ï¼Œä¸Šåˆå…ˆå¯«18é¡Œï¼Œä¸‹åˆå†å¯«17é¡Œï¼Œé‚„å‰©å¹¾é¡Œæ²’å¯«ï¼Ÿ", options: ["10é¡Œ", "11é¡Œ", "12é¡Œ", "20é¡Œ"], answer: "10é¡Œ" },
            { q: "äºŒå¹´1ç­æœ‰14å€‹ç”·ç”Ÿå’Œ13å€‹å¥³ç”Ÿï¼Œä»Šæ—¥æœ‰9å€‹å­¸ç”Ÿè«‹å‡ï¼Œæœ‰ä¾†ä¸Šèª²çš„å­¸ç”Ÿæ˜¯å¹¾å€‹ï¼Ÿ", options: ["18å€‹", "17å€‹", "19å€‹", "27å€‹"], answer: "18å€‹" },
            { q: "åšç‰©é¤¨è£¡æœ‰85å€‹éŠå®¢ï¼Œ36å€‹éŠå®¢é›¢é–‹å¾Œï¼Œåˆé€²ä¾†20å€‹ï¼Œåšç‰©é¤¨è£¡ç¾åœ¨æœ‰å¹¾å€‹éŠå®¢ï¼Ÿ", options: ["69å€‹", "29å€‹", "105å€‹", "141å€‹"], answer: "69å€‹" },
            { q: "é«”è‚²è€å¸«ç™»è¨˜é‹å‹•æœƒé …ç›®ï¼ŒçŸ­è·‘æœ‰32å€‹äººå ±åï¼Œæ¥åŠ›è³½æœ‰25å€‹äººå ±åï¼Œè·³é æœ‰18å€‹äººå ±åï¼Œå…±æœ‰å¹¾å€‹äººå ±ååƒåŠ æ¯”è³½ï¼Ÿ", options: ["75å€‹", "74å€‹", "39å€‹", "57å€‹"], answer: "75å€‹" },
            { q: "å°è±ªæœ‰90å…ƒï¼Œè²·ç©å…·ç”¨äº†35å…ƒï¼Œåˆè²·é£²æ–™ç”¨äº†28å…ƒï¼Œå°è±ªé‚„å‰©ä¸‹å¹¾å…ƒï¼Ÿ", options: ["27å…ƒ", "83å…ƒ", "97å…ƒ", "55å…ƒ"], answer: "27å…ƒ" },
            { q: "è¨ˆç®—ã€Œ21ï¼‹33ï¼‹19ï¼ï¼Ÿã€ï¼Œæ­£ç¢ºç­”æ¡ˆæ˜¯å¤šå°‘ï¼Ÿ", options: ["73", "63", "83", "71"], answer: "73" },
            { q: "æ•™å®¤çš„æ›¸æ¶ä¸ŠåŸæœ‰55æœ¬æ›¸ï¼Œä¸Šåˆå…ˆå€Ÿå‡º24æœ¬ï¼Œä¸‹åˆå†å€Ÿå‡º20æœ¬ï¼Œæ›¸æ¶ä¸Šé‚„å‰©å¹¾æœ¬æ›¸ï¼Ÿ", options: ["11æœ¬", "51æœ¬", "59æœ¬", "31æœ¬"], answer: "11æœ¬" },
            { q: "å’–å•¡å»³æœ€å¤šå¯ä»¥æä¾›35å€‹åº§ä½ï¼Œç¾åœ¨æœ‰18å€‹äººï¼Œåˆé€²ä¾†14å€‹ï¼Œæœ€å¤šé‚„å¯ä»¥å†é€²ä¾†å¹¾å€‹äººï¼Ÿ", options: ["3å€‹", "39å€‹", "31å€‹", "32å€‹"], answer: "3å€‹" },
            { q: "é˜¿ä¾å¸¶80å…ƒå»æ°´æœåº—è²·äº†45å…ƒçš„å¥‡ç•°æœå’Œ32å…ƒçš„é¦™è•‰å¾Œï¼Œé‚„å‰©ä¸‹å¹¾å…ƒï¼Ÿ", options: ["3å…ƒ", "35å…ƒ", "48å…ƒ", "13å…ƒ"], answer: "3å…ƒ" },
            { q: "æ›¸æ¶ä¸ŠåŸæœ‰55æœ¬æ›¸ï¼Œå°è¯æ‹¿èµ°28æœ¬å¾Œï¼Œå°èŠ³åˆæ”¾å…¥16æœ¬ï¼Œç¾åœ¨æ›¸æ¶ä¸Šæœ‰å¹¾æœ¬æ›¸ï¼Ÿ", options: ["43æœ¬", "67æœ¬", "11æœ¬", "27æœ¬"], answer: "43æœ¬" },
            { q: "å°å‰å¯«åœ‹èªä½œæ¥­èŠ±äº†20åˆ†é˜ï¼Œæ•¸å­¸ä½œæ¥­èŠ±äº†15åˆ†é˜ï¼Œè‡ªç„¶ä½œæ¥­åˆèŠ±äº†25åˆ†é˜ï¼Œå°å‰å¯«ä½œæ¥­å…±èŠ±äº†å¹¾åˆ†é˜ï¼Ÿ", options: ["60åˆ†é˜", "61åˆ†é˜", "70åˆ†é˜", "30åˆ†é˜"], answer: "60åˆ†é˜" },
            { q: "å°è±ªåŸæœ¬æœ‰20å…ƒï¼Œçˆ¸çˆ¸çµ¦ä»–14å…ƒå¾Œï¼Œåª½åª½å†çµ¦ä»–13å…ƒï¼Œå°è±ªç¾åœ¨æœ‰å¤šå°‘å…ƒï¼Ÿ", options: ["47å…ƒ", "57å…ƒ", "67å…ƒ", "37å…ƒ"], answer: "47å…ƒ" },
            { q: "å°ç±³æœ‰50å…ƒï¼Œè²·æ—©é¤ç”¨å»18å…ƒï¼Œè²·é£²æ–™ç”¨å»20å…ƒï¼Œå°ç±³é‚„å‰©å¹¾å…ƒï¼Ÿ", options: ["12å…ƒ", "14å…ƒ", "13å…ƒ", "22å…ƒ"], answer: "12å…ƒ" }
        ];

        const Utils = {
            shuffleArray(array) {
                const newArray = [...array];
                for (let i = newArray.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
                }
                return newArray;
            },
            generateOptions(correctAnswer, range) {
                const options = [correctAnswer];
                let attempts = 0;
                while (options.length < 4 && attempts < 100) {
                    attempts++;
                    let option;
                    if (typeof correctAnswer === 'number') {
                        // æ ¹æ“šæ­£ç¢ºç­”æ¡ˆçš„å¤§å°ä¾†æ±ºå®šåç§»é‡ï¼Œé¿å…åœ¨å¤§æ•¸é¡æ™‚åç§»å¤ªå°
                        const magnitude = Math.max(1, Math.pow(10, Math.floor(Math.log10(correctAnswer || 1)) - 1));
                        const offset = (Math.floor(Math.random() * 21) - 10) * magnitude;
                        option = correctAnswer + offset;
                        if (option < 0) option = Math.abs(option);
                        if (option > range && range > 0) option = option % (range + 1);
                    } else {
                        option = Math.floor(Math.random() * range);
                    }
                    if (!options.includes(option) && option >= 0) {
                        options.push(option);
                    }
                }
                // å¦‚æœå¤±æ•—ï¼Œå¼·åˆ¶å¡«æ»¿
                while (options.length < 4) {
                    const lastOption = options[options.length - 1];
                    options.push(typeof lastOption === 'number' ? lastOption + 1 : options.length);
                }
                return this.shuffleArray(options);
            },
            generateMultiplicationOptions(correct) {
                const options = [correct];
                const possibleAnswers = [];
                for (let i = 2; i <= 9; i++) {
                    for (let j = 2; j <= 9; j++) {
                        const result = i * j;
                        if (result !== correct && Math.abs(result - correct) <= 20) {
                            possibleAnswers.push(result);
                        }
                    }
                }
                while (options.length < 4 && possibleAnswers.length > 0) {
                    const randomIndex = Math.floor(Math.random() * possibleAnswers.length);
                    const option = possibleAnswers[randomIndex];
                    if (!options.includes(option)) {
                        options.push(option);
                    }
                    possibleAnswers.splice(randomIndex, 1);
                }
                let attempts = 0;
                while (options.length < 4 && attempts < 100) {
                    attempts++;
                    const offset = Math.floor(Math.random() * 10) + 1;
                    const option = Math.random() > 0.5 ? correct + offset : correct - offset;
                    if (option > 0 && !options.includes(option)) {
                        options.push(option);
                    }
                }
                // å¦‚æœå¤±æ•—ï¼Œå¼·åˆ¶å¡«æ»¿
                while (options.length < 4) {
                    const lastOption = options[options.length - 1];
                    options.push(lastOption + 1);
                }
                return this.shuffleArray(options);
            },
            generateDynamicStory() {
                const types = [
                    {
                        // å‹æ…‹ 1: A + B - C (å…ˆå¢åŠ å¾Œæ¸›å°‘)
                        templates: [
                            { unit: "å¡Š", text: (a, b, c) => `å°å…‰æœ‰ ${a} å¡Šç©æœ¨ï¼Œå°è¯çµ¦ä»– ${b} å¡Šå¾Œï¼Œå°å…‰åˆå€Ÿçµ¦åŒå­¸ ${c} å¡Šï¼Œå°å…‰ç¾åœ¨æœ‰å¹¾å¡Šç©æœ¨ï¼Ÿ` },
                            { unit: "å€‹äºº", text: (a, b, c) => `çƒæ± è£¡åŸæœ¬æœ‰ ${a} å€‹äººï¼Œåˆé€²ä¾†äº† ${b} å€‹äººï¼Œå¾Œä¾†é›¢é–‹äº† ${c} å€‹äººï¼Œç¾åœ¨çƒæ± è£¡æœ‰å¹¾å€‹äººï¼Ÿ` },
                            { unit: "å€‹äºº", text: (a, b, c) => `å…¬è»Šä¸ŠåŸæœ¬æœ‰ ${a} å€‹äººï¼Œåˆ°ç«™å¾Œä¸Šä¾†äº† ${b} å€‹äººï¼Œåˆä¸‹è»Šäº† ${c} å€‹äººï¼Œç¾åœ¨è»Šä¸Šæœ‰å¹¾å€‹äººï¼Ÿ` }
                        ],
                        logic: () => {
                            const a = Math.floor(Math.random() * 30) + 20; // 20-50
                            const b = Math.floor(Math.random() * 20) + 10; // 10-30
                            const c = Math.floor(Math.random() * (a + b - 10)) + 5; // ç¢ºä¿å‰©é¤˜è‡³å°‘10
                            const ans = a + b - c;
                            return { vars: [a, b, c], answer: ans };
                        }
                    },
                    {
                        // å‹æ…‹ 2: A - B - C (é€£çºŒæ¸›å°‘)
                        templates: [
                            { unit: "é¡†", text: (a, b, c) => `åª½åª½è²·äº† ${a} é¡†ç³–æœï¼Œåˆ†çµ¦å“¥å“¥ ${b} é¡†ï¼Œåˆåˆ†çµ¦å¦¹å¦¹ ${c} é¡†ï¼Œåª½åª½é‚„å‰©å¹¾é¡†ç³–æœï¼Ÿ` },
                            { unit: "å…ƒ", text: (a, b, c) => `å°è±ªæœ‰ ${a} å…ƒï¼Œè²·æ–‡å…·ç”¨äº† ${b} å…ƒï¼Œè²·é£²æ–™ç”¨äº† ${c} å…ƒï¼Œå°è±ªé‚„å‰©ä¸‹å¹¾å…ƒï¼Ÿ` },
                            { unit: "å€‹", text: (a, b, c) => `ç®±å­è£¡æœ‰ ${a} å€‹è˜‹æœï¼Œä¸Šåˆé‹èµ° ${b} å€‹ï¼Œä¸‹åˆåˆé‹èµ° ${c} å€‹ï¼Œç®±å­é‚„å‰©å¹¾å€‹è˜‹æœï¼Ÿ` }
                        ],
                        logic: () => {
                            const a = Math.floor(Math.random() * 40) + 50; // 50-90
                            const b = Math.floor(Math.random() * 20) + 10; // 10-30
                            const c = Math.floor(Math.random() * (a - b - 10)) + 5; // ç¢ºä¿å‰©é¤˜è‡³å°‘10
                            const ans = a - b - c;
                            return { vars: [a, b, c], answer: ans };
                        }
                    },
                    {
                        // å‹æ…‹ 3: A + B + C (ä¸‰é …åŠ æ³•)
                        templates: [
                            { unit: "å€‹", text: (a, b, c) => `æ°´æœåº—æœ‰ ${a} å€‹è˜‹æœã€${b} å€‹æ©˜å­å’Œ ${c} å€‹æ¢¨å­ï¼Œé€™ä¸‰ç¨®æ°´æœå…±æœ‰å¹¾å€‹ï¼Ÿ` },
                            { unit: "å€‹", text: (a, b, c) => `å°ç¾ç¬¬ä¸€ç¯€èª²èƒŒäº† ${a} å€‹å–®å­—ï¼Œç¬¬äºŒç¯€èƒŒäº† ${b} å€‹ï¼Œç¬¬ä¸‰ç¯€åˆèƒŒäº† ${c} å€‹ï¼Œå°ç¾å…±èƒŒäº†å¹¾å€‹å–®å­—ï¼Ÿ` },
                            { unit: "ä½", text: (a, b, c) => `äºŒå¹´ç´šä¸€ç­æœ‰ ${a} å€‹ç”·ç”Ÿï¼ŒäºŒç­æœ‰ ${b} å€‹ç”·ç”Ÿï¼Œä¸‰ç­æœ‰ ${c} å€‹ç”·ç”Ÿï¼Œé€™ä¸‰å€‹ç­å…±æœ‰å¹¾å€‹ç”·ç”Ÿï¼Ÿ` }
                        ],
                        logic: () => {
                            const a = Math.floor(Math.random() * 20) + 10; // 10-30
                            const b = Math.floor(Math.random() * 20) + 10; // 10-30
                            const c = Math.floor(Math.random() * 20) + 10; // 10-30
                            const ans = a + b + c;
                            return { vars: [a, b, c], answer: ans };
                        }
                    }
                ];

                const type = types[Math.floor(Math.random() * types.length)];
                const data = type.logic();
                const templateObj = type.templates[Math.floor(Math.random() * type.templates.length)];
                
                const q = templateObj.text(...data.vars);
                const unit = templateObj.unit;

                // ç”Ÿæˆå¹²æ“¾é¸é …
                const ans = data.answer;
                const options = [ans];
                
                // å¢åŠ éŒ¯èª¤è·¯å¾‘å¹²æ“¾
                const [a, b, c] = data.vars;
                const distractor1 = a + b + c; // èª¤åŠ 
                const distractor2 = Math.abs(a - b - c); // èª¤æ¸›
                const distractor3 = a + b; // æ¼æ‰æœ€å¾Œä¸€æ­¥
                
                [distractor1, distractor2, distractor3].forEach(d => {
                    if (d !== ans && d > 0 && !options.includes(d)) options.push(d);
                });

                // å¦‚æœé‚„ä¸è¶³ 4 å€‹ï¼Œä½¿ç”¨éš¨æ©Ÿåç§»
                let attempts = 0;
                while (options.length < 4 && attempts < 100) {
                    attempts++;
                    const offset = Math.floor(Math.random() * 10) + 1;
                    const opt = Math.random() > 0.5 ? ans + offset : ans - offset;
                    if (opt > 0 && !options.includes(opt)) options.push(opt);
                }
                // å¦‚æœå¤±æ•—ï¼Œå¼·åˆ¶å¡«æ»¿
                while (options.length < 4) {
                    const lastOption = options[options.length - 1];
                    options.push(lastOption + 1);
                }
                
                return {
                    question: q,
                    answer: ans + unit,
                    options: this.shuffleArray(options.map(o => o + unit))
                };
            },
            getCoinSvg(value) {
                const colors = {
                    1: { bg: '#e67e22', border: '#d35400', text: '#fff' },
                    5: { bg: '#95a5a6', border: '#7f8c8d', text: '#fff' },
                    10: { bg: '#f1c40f', border: '#f39c12', text: '#8b4513' },
                    50: { bg: '#f1c40f', border: '#d35400', text: '#8b4513' },
                    100: { bg: '#e74c3c', border: '#c0392b', text: '#fff' },
                    500: { bg: '#2ecc71', border: '#27ae60', text: '#fff' },
                    1000: { bg: '#3498db', border: '#2980b9', text: '#fff' }
                };
                const c = colors[value] || colors[1];
                const isBill = value >= 100;
                if (isBill) {
                    const fontSize = value >= 1000 ? 22 : 26;
                    return `<svg viewBox="0 0 100 60" xmlns="http://www.w3.org/2000/svg">
                        <rect x="2" y="2" width="96" height="56" rx="5" fill="${c.bg}" stroke="${c.border}" stroke-width="2"/>
                        <circle cx="50" cy="30" r="15" fill="none" stroke="${c.border}" stroke-width="1" opacity="0.5"/>
                        <text x="50" y="38" font-family="Arial" font-size="${fontSize}" font-weight="bold" fill="${c.text}" text-anchor="middle">${value}</text>
                    </svg>`;
                }
                return `<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                    <circle cx="50" cy="50" r="45" fill="${c.bg}" stroke="${c.border}" stroke-width="3"/>
                    <circle cx="50" cy="50" r="35" fill="none" stroke="${c.border}" stroke-width="1" stroke-dasharray="2,2"/>
                    <text x="50" y="65" font-family="Arial" font-size="40" font-weight="bold" fill="${c.text}" text-anchor="middle">${value}</text>
                </svg>`;
            }
        };

        const AudioSystem = {
            context: null,
            init() {
                this.context = new (window.AudioContext || window.webkitAudioContext)();
            },
            playCorrect() {
                try {
                    if (!this.context) this.init();
                    if (this.context.state === 'suspended') this.context.resume();
                    const oscillator = this.context.createOscillator();
                    const gainNode = this.context.createGain();
                    oscillator.connect(gainNode);
                    gainNode.connect(this.context.destination);
                    oscillator.frequency.setValueAtTime(523.25, this.context.currentTime);
                    oscillator.frequency.setValueAtTime(659.25, this.context.currentTime + 0.1);
                    oscillator.frequency.setValueAtTime(783.99, this.context.currentTime + 0.2);
                    gainNode.gain.setValueAtTime(0.3, this.context.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.3);
                    oscillator.start(this.context.currentTime);
                    oscillator.stop(this.context.currentTime + 0.3);
                } catch (e) {
                    console.error('Audio play error:', e);
                }
            },
            playWrong() {
                try {
                    if (!this.context) this.init();
                    if (this.context.state === 'suspended') this.context.resume();
                    const oscillator = this.context.createOscillator();
                    const gainNode = this.context.createGain();
                    oscillator.connect(gainNode);
                    gainNode.connect(this.context.destination);
                    oscillator.frequency.setValueAtTime(200, this.context.currentTime);
                    oscillator.type = 'sawtooth';
                    gainNode.gain.setValueAtTime(0.3, this.context.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.2);
                    oscillator.start(this.context.currentTime);
                    oscillator.stop(this.context.currentTime + 0.2);
                } catch (e) {
                    console.error('Audio play error:', e);
                }
            },
            playComplete() {
                try {
                    if (!this.context) this.init();
                    if (this.context.state === 'suspended') {
                        this.context.resume().then(() => this._playCompleteNotes());
                    } else {
                        this._playCompleteNotes();
                    }
                } catch (e) {
                    console.error('Audio play error:', e);
                }
            },
            _playCompleteNotes() {
                try {
                    const notes = [523.25, 587.33, 659.25, 783.99];
                    notes.forEach((freq, i) => {
                        const oscillator = this.context.createOscillator();
                        const gainNode = this.context.createGain();
                        oscillator.connect(gainNode);
                        gainNode.connect(this.context.destination);
                        oscillator.frequency.setValueAtTime(freq, this.context.currentTime + i * 0.15);
                        gainNode.gain.setValueAtTime(0.2, this.context.currentTime + i * 0.15);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + i * 0.15 + 0.3);
                        oscillator.start(this.context.currentTime + i * 0.15);
                        oscillator.stop(this.context.currentTime + i * 0.15 + 0.3);
                    });
                } catch (e) {
                    console.error('Notes play error:', e);
                }
            }
        };

        const Levels = [
            {
                id: 1,
                name: 'æ•¸å­—é­”æ³•å¸«',
                icon: 'ğŸ§™â€â™‚ï¸',
                generateQuestion: (difficulty) => {
                    const isEasy = difficulty === 'easy';
                    let num1, num2, operator, answer;
                    if (isEasy) {
                        operator = Math.random() > 0.5 ? '+' : '-';
                        if (operator === '+') {
                            num1 = Math.floor(Math.random() * 9) + 1;
                            num2 = Math.floor(Math.random() * (10 - num1)) + 1;
                            answer = num1 + num2;
                        } else {
                            answer = Math.floor(Math.random() * 9) + 1;
                            num2 = Math.floor(Math.random() * answer) + 1;
                            num1 = answer + num2;
                            answer = num1 - num2;
                        }
                    } else {
                        operator = Math.random() > 0.5 ? '+' : '-';
                        if (operator === '+') {
                            num1 = Math.floor(Math.random() * 90) + 10;
                            num2 = Math.floor(Math.random() * (100 - num1)) + 1;
                            answer = num1 + num2;
                        } else {
                            answer = Math.floor(Math.random() * 90) + 10;
                            num2 = Math.floor(Math.random() * answer) + 1;
                            num1 = answer + num2;
                            answer = num1 - num2;
                        }
                    }
                    return {
                        question: `${num1} ${operator} ${num2} = ?`,
                        answer: answer,
                        options: Utils.generateOptions(answer, isEasy ? 10 : 100)
                    };
                }
            },
            {
                id: 2,
                name: 'æ•…äº‹è¿·å®®',
                icon: 'ğŸ“–',
                generateQuestion: (difficulty) => {
                    const isEasy = difficulty === 'easy';
                    if (isEasy) {
                        const scenarios = [
                            (a, b) => ({
                                q: `å°æ˜æœ‰ ${a} é¡†ç³–æœï¼Œåª½åª½åˆçµ¦ä»– ${b} é¡†ï¼Œå°æ˜ç¾åœ¨æœ‰å¹¾é¡†ç³–æœï¼Ÿ`,
                                a: a + b
                            }),
                            (a, b) => ({
                                q: `æ¨¹ä¸Šæœ‰ ${a} éš»å°é³¥ï¼Œé£›èµ°äº† ${b} éš»ï¼Œé‚„å‰©ä¸‹å¹¾éš»å°é³¥ï¼Ÿ`,
                                a: a - b
                            }),
                            (a, b) => ({
                                q: `ç±ƒå­è£¡æœ‰ ${a} é¡†è˜‹æœï¼Œå°è¯åƒæ‰ ${b} é¡†ï¼Œé‚„å‰©ä¸‹å¹¾é¡†è˜‹æœï¼Ÿ`,
                                a: a - b
                            }),
                            (a, b) => ({
                                q: `æ›¸æ¶ä¸ŠåŸæœ¬æœ‰ ${a} æœ¬æ•…äº‹æ›¸ï¼Œçˆ¸çˆ¸åˆè²·äº† ${b} æœ¬çµ¦å°æ˜ï¼Œç¾åœ¨æ›¸æ¶ä¸Šå…±æœ‰å¹¾æœ¬æ›¸ï¼Ÿ`,
                                a: a + b
                            }),
                            (a, b) => ({
                                q: `èŠ±åœ’è£¡é–‹äº† ${a} æœµç´…èŠ±ï¼Œæ—é‚Šé‚„æœ‰ ${b} æœµé»ƒèŠ±ï¼ŒèŠ±åœ’è£¡ç¸½å…±æœ‰å¹¾æœµèŠ±ï¼Ÿ`,
                                a: a + b
                            }),
                            (a, b) => ({
                                q: `å°è±¬æ’²æ»¿è£¡æœ‰ ${a} å…ƒï¼Œå°ç¾ä»Šå¤©åˆå­˜é€²å» ${b} å…ƒï¼Œç¾åœ¨æ’²æ»¿è£¡æœ‰å¤šå°‘éŒ¢ï¼Ÿ`,
                                a: a + b
                            }),
                            (a, b) => ({
                                q: `åœè»Šå ´è£¡åœäº† ${a} è¼›ç´…è‰²æ±½è»Šå’Œ ${b} è¼›è—è‰²æ±½è»Šï¼Œåœè»Šå ´è£¡ç¸½å…±æœ‰å¹¾è¼›è»Šï¼Ÿ`,
                                a: a + b
                            }),
                            (a, b) => ({
                                q: `åœè»Šå ´åŸæœ¬æœ‰ ${a} è¼›è»Šï¼Œé–‹èµ°äº† ${b} è¼›ï¼Œç¾åœ¨åœè»Šå ´é‚„å‰©ä¸‹å¹¾è¼›è»Šï¼Ÿ`,
                                a: a - b
                            }),
                            (a, b) => ({
                                q: `å†°ç®±è£¡æœ‰ ${a} é¡†é›è›‹ï¼Œåª½åª½åšè›‹ç³•ç”¨æ‰äº† ${b} é¡†ï¼Œå†°ç®±é‚„å‰©ä¸‹å¹¾é¡†é›è›‹ï¼Ÿ`,
                                a: a - b
                            }),
                            (a, b) => ({
                                q: `å°ä¸‘æ‰‹ä¸Šæœ‰ ${a} å€‹æ°£çƒï¼Œä¸å°å¿ƒé£›èµ°äº† ${b} å€‹ï¼Œå°ä¸‘æ‰‹ä¸Šé‚„å‰©ä¸‹å¹¾å€‹æ°£çƒï¼Ÿ`,
                                a: a - b
                            }),
                            (a, b) => ({
                                q: `å…¬è»Šä¸ŠåŸæœ¬æœ‰ ${a} å€‹äººï¼Œåˆ°äº†è»Šç«™å¾Œä¸‹è»Šäº† ${b} å€‹äººï¼Œç¾åœ¨è»Šä¸Šé‚„æœ‰å¹¾å€‹äººï¼Ÿ`,
                                a: a - b
                            })
                        ];
                        const scenario = scenarios[Math.floor(Math.random() * scenarios.length)];
                        const num1 = Math.floor(Math.random() * 15) + 5;
                        const num2 = Math.floor(Math.random() * num1) + 1;
                        const result = scenario(num1, num2);
                        return {
                            question: result.q,
                            answer: result.a,
                            options: Utils.generateOptions(result.a, 20)
                        };
                    } else {
                        // å›°é›£æ¨¡å¼ï¼š50% æ©Ÿç‡å¾é¡Œåº«æŠ½é¡Œï¼Œ50% æ©Ÿç‡éš¨æ©Ÿç”Ÿæˆ
                        if (Math.random() > 0.5) {
                            return Utils.generateDynamicStory();
                        } else {
                            const randomIdx = Math.floor(Math.random() * STORY_MAZE_HARD_QUESTIONS.length);
                            const qData = STORY_MAZE_HARD_QUESTIONS[randomIdx];
                            return {
                                question: qData.q,
                                answer: qData.answer,
                                options: Utils.shuffleArray([...qData.options])
                            };
                        }
                    }
                }
            },
            {
                id: 3,
                name: 'ä¹˜æ³•æ¢éšªå®¶',
                icon: 'âœ–ï¸',
                generateQuestion: (difficulty) => {
                    const isEasy = difficulty === 'easy';
                    let num1, num2;
                    if (isEasy) {
                        const multipliers = [2, 3, 4, 5];
                        num1 = multipliers[Math.floor(Math.random() * multipliers.length)];
                        num2 = Math.floor(Math.random() * 9) + 1;
                    } else {
                        num1 = Math.floor(Math.random() * 9) + 1;
                        num2 = Math.floor(Math.random() * 9) + 1;
                    }
                    const answer = num1 * num2;
                    return {
                        question: `${num1} Ã— ${num2} = ?`,
                        answer: answer,
                        options: Utils.generateOptions(answer, isEasy ? 50 : 81)
                    };
                }
            },
            {
                id: 4,
                name: 'å¤§å°é­”ç‹æˆ°',
                icon: 'âš”ï¸',
                generateQuestion: (difficulty) => {
                    const isEasy = difficulty === 'easy';
                    let num1, num2;
                    if (isEasy) {
                        num1 = Math.floor(Math.random() * 90) + 10;
                        num2 = Math.floor(Math.random() * 90) + 10;
                    } else {
                        num1 = Math.floor(Math.random() * 900) + 100;
                        num2 = Math.floor(Math.random() * 900) + 100;
                    }
                    let answer;
                    if (num1 > num2) answer = '>';
                    else if (num1 < num2) answer = '<';
                    else answer = '=';
                    return {
                        question: `${num1} _____ ${num2}`,
                        answer: answer,
                        options: ['<', '>', '='],
                        isComparison: true
                    };
                }
            },
            {
                id: 5,
                name: 'éŒ¢å¹£å¤§å¯Œç¿',
                icon: 'ğŸ’°',
                generateQuestion: (difficulty) => {
                    const isEasy = difficulty === 'easy';
                    const coinConfigs = isEasy ? [
                        { value: 1, max: 10 },
                        { value: 5, max: 5 },
                        { value: 10, max: 3 }
                    ] : [
                        { value: 1, max: 10 },
                        { value: 5, max: 5 },
                        { value: 10, max: 5 },
                        { value: 50, max: 2 },
                        { value: 100, max: 2 },
                        { value: 500, max: 2 },
                        { value: 1000, max: 1 }
                    ];

                    // éš¨æ©Ÿé¸å– 2-4 ç¨®éŒ¢å¹£
                    const selectedConfigs = Utils.shuffleArray(coinConfigs).slice(0, isEasy ? 2 : 4);
                    // æŒ‰ç…§å¹£å€¼å¤§åˆ°å°æ’åºï¼Œè¦–è¦ºä¸Šæ¯”è¼ƒæ•´é½Š
                    selectedConfigs.sort((a, b) => b.value - a.value);
                    let total = 0;
                    let coinsHtml = '';

                    selectedConfigs.forEach(config => {
                        const count = Math.floor(Math.random() * config.max) + 1;
                        total += config.value * count;
                        coinsHtml += `<div class="coin-row">`;
                        for (let i = 0; i < count; i++) {
                            const isBill = config.value >= 100;
                            const billClass = isBill ? 'is-bill' : '';
                            coinsHtml += `
                                <div class="coin-wrapper ${billClass}" style="margin: 1px;">
                                    <div class="coin-img">${Utils.getCoinSvg(config.value)}</div>
                                </div>
                            `;
                        }
                        coinsHtml += `<div class="coin-row-count">x ${count}</div>`;
                        coinsHtml += `</div>`;
                    });

                    return {
                        question: `ä½ æœ‰é€™äº›éŒ¢ï¼Œç¸½å…±æœ‰å¤šå°‘å…ƒï¼Ÿ`,
                        coinsHtml: coinsHtml,
                        answer: total,
                        options: Utils.generateOptions(total, isEasy ? 100 : 3000)
                    };
                }
            },
            {
                id: 6,
                name: 'æ™‚é–“é­”æ³•é˜',
                icon: 'ğŸ•',
                generateQuestion: (difficulty) => {
                    const isEasy = difficulty === 'easy';
                    let hour, minute, answer;
                    if (isEasy) {
                        // Easy mode: 5-minute intervals
                        hour = Math.floor(Math.random() * 12) + 1;
                        minute = Math.floor(Math.random() * 12) * 5;
                    } else {
                        // Hard mode: 1-minute intervals
                        hour = Math.floor(Math.random() * 12) + 1;
                        minute = Math.floor(Math.random() * 60);
                    }
                    const formatTime = (h, m) => `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
                    answer = formatTime(hour, minute);
                    return {
                        question: 'ç¾åœ¨æ˜¯å¹¾é»ï¼Ÿ',
                        answer: answer,
                        hour: hour,
                        minute: minute,
                        options: generateTimeOptions(hour, minute, isEasy),
                        isClock: true
                    };
                }
            }
        ];

        // ç¨ç«‹çš„ç·´ç¿’é—œå¡
        const PracticeLevels = [
            {
                id: 99,
                name: 'ä¹ä¹ä¹˜æ³•ç‹',
                icon: 'ğŸ”¢',
                generateQuestion: (difficulty) => {
                    const isEasy = difficulty === 'easy';
                    let num1, num2;

                    if (isEasy) {
                        // ç°¡å–®æ¨¡å¼ï¼š2-5çš„ä¹˜æ³•è¡¨
                        num1 = Math.floor(Math.random() * 4) + 2;
                        num2 = Math.floor(Math.random() * 8) + 2;
                    } else {
                        // å›°é›£æ¨¡å¼ï¼šå®Œæ•´ä¹ä¹ä¹˜æ³•è¡¨ 2-9
                        num1 = Math.floor(Math.random() * 8) + 2;
                        num2 = Math.floor(Math.random() * 8) + 2;
                    }

                    const answer = num1 * num2;

                    // ç”¢ç”Ÿæ›´å…·æŒ‘æˆ°æ€§çš„é¸é …
                    return {
                        question: `${num1} Ã— ${num2} = ?`,
                        answer: answer,
                        options: Utils.generateMultiplicationOptions(answer)
                    };
                }
            }
        ];

        function generateTimeOptions(hour, minute, isEasy) {
            const formatTime = (h, m) => `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
            const correctAnswer = formatTime(hour, minute);
            const options = [correctAnswer];

            if (!isEasy) {
                // å›°é›£æ¨¡å¼ï¼šå¼·åˆ¶åŠ å…¥å°æ™‚æ•¸ +-1 çš„é¸é …
                const prevHour = hour - 1 < 1 ? 12 : hour - 1;
                const nextHour = hour + 1 > 12 ? 1 : hour + 1;

                const opt1 = formatTime(prevHour, minute);
                const opt2 = formatTime(nextHour, minute);

                if (!options.includes(opt1)) options.push(opt1);
                if (!options.includes(opt2)) options.push(opt2);
            }

            let attempts = 0;
            while (options.length < 4 && attempts < 100) {
                attempts++;
                // æ­¥é©Ÿ 1: è®“å°æ™‚ h æ¥è¿‘ç­”æ¡ˆ hour (+- 1 å°æ™‚)
                let h;
                const hourRange = 1; // æ¥è¿‘ç¯„åœï¼š+- 1 å°æ™‚

                // åœ¨ [hour - 1, hour + 1] ç¯„åœå…§éš¨æ©Ÿç”Ÿæˆå°æ™‚ (ä½†éœ€è€ƒæ…® 12 å°æ™‚åˆ¶)
                const minH = hour - hourRange;
                const maxH = hour + hourRange;

                // éš¨æ©Ÿåœ¨ minH åˆ° maxH ä¹‹é–“ç”Ÿæˆ h
                h = Math.floor(Math.random() * (maxH - minH + 1)) + minH;

                // è™•ç† h è¶…å‡º 1-12 ç¯„åœçš„æƒ…æ³ï¼Œä¾‹å¦‚ 12 + 1 = 1ï¼Œ 1 - 1 = 12
                h = (h < 1) ? 12 : (h > 12) ? 1 : h;

                // æ­¥é©Ÿ 2: è®“åˆ†é˜ m æ¥è¿‘ç­”æ¡ˆ minute (+- 15 åˆ†é˜)
                let m;
                const minuteRange = isEasy ? 15 : 5;
                const minM = Math.max(0, minute - minuteRange);
                const maxM = Math.min(59, minute + minuteRange);

                if (isEasy) {
                    // åœ¨æ¥è¿‘ç¯„åœå…§ç”Ÿæˆ 5 çš„å€æ•¸
                    m = Math.floor(Math.random() * 12) * 5;
                } else {
                    // åœ¨æ¥è¿‘ç¯„åœå…§ç”Ÿæˆä»»æ„åˆ†é˜
                    m = Math.floor(Math.random() * 60);
                }

                const option = formatTime(h, m);
                if (!options.includes(option)) {
                    options.push(option);
                }
            }

            // å¦‚æœå¤±æ•—ï¼Œå¼·åˆ¶å¡«æ»¿
            while (options.length < 4) {
                const lastOption = options[options.length - 1];
                const [h, m] = lastOption.split(':').map(Number);
                options.push(formatTime(h, (m + 5) % 60));
            }
            return Utils.shuffleArray(options);
        }

        function drawClock(hour, minute) {
            const container = document.getElementById('clockContainerInner');
            if (!container) return;
            let ticksHtml = '';
            for (let i = 0; i < 60; i++) {
                const isHour = i % 5 === 0;
                const h = isHour ? 15 : 8; // %
                const w = isHour ? 2 : 1; // px
                const angle = i * 6;

                ticksHtml += `<div class="clock-tick" style="width: ${w}px; height: 50%; transform: translateX(-50%) rotate(${angle}deg);">
                    <div class="clock-tick-inner" style="height: ${h}%;"></div>
                </div>`;
            }

            let numbersHtml = '';
            for (let i = 1; i <= 12; i++) {
                const angleRad = (i * 30 - 90) * (Math.PI / 180);
                const radius = 38;
                const x = 50 + radius * Math.cos(angleRad);
                const y = 50 + radius * Math.sin(angleRad);
                numbersHtml += `<div class="clock-number" style="left: ${x}%; top: ${y}%">${i}</div>`;
            }
            container.innerHTML = `
                ${ticksHtml}
                ${numbersHtml}
                <div class="clock-center"></div>
                <div class="clock-hand hour-hand" id="hourHand"></div>
                <div class="clock-hand minute-hand" id="minuteHand"></div>
            `;
            
            // ä½¿ç”¨ setTimeout ç¢ºä¿ DOM å·²æ¸²æŸ“ï¼Œå¾è€Œè§¸ç™¼ CSS transition
            setTimeout(() => {
                const hourHand = document.getElementById('hourHand');
                const minuteHand = document.getElementById('minuteHand');
                if (hourHand && minuteHand) {
                    hourHand.style.transform = `rotate(${(hour % 12) * 30 + minute * 0.5}deg)`;
                    minuteHand.style.transform = `rotate(${minute * 6}deg)`;
                }
            }, 50);
        }

        const Storage = {
            getRecord(levelId, difficulty) {
                const key = `level_${levelId}_${difficulty}`;
                return parseInt(localStorage.getItem(key)) || 0;
            },
            saveRecord(levelId, difficulty, stars) {
                const key = `level_${levelId}_${difficulty}`;
                const current = this.getRecord(levelId, difficulty);
                if (stars > current) {
                    localStorage.setItem(key, stars);
                }
            },
            getUsedStars() {
                return parseInt(localStorage.getItem('stars_used')) || 0;
            },
            useStars(count) {
                const current = this.getUsedStars();
                localStorage.setItem('stars_used', current + count);
            },
            consumeStarsSequentially(count) {
                let remainingToConsume = count;
                // å®šç¾©é †åºï¼šé—œå¡ 1->6ï¼Œæ¯å€‹é—œå¡å…ˆæ‰£ç°¡å–®å†æ‰£å›°é›£
                for (let levelId = 1; levelId <= 6; levelId++) {
                    const difficulties = ['easy', 'hard'];
                    for (const diff of difficulties) {
                        if (remainingToConsume <= 0) break;
                        
                        const key = `level_${levelId}_${diff}`;
                        let stars = parseInt(localStorage.getItem(key)) || 0;
                        
                        if (stars > 0) {
                            const consume = Math.min(stars, remainingToConsume);
                            stars -= consume;
                            remainingToConsume -= consume;
                            
                            if (stars > 0) {
                                localStorage.setItem(key, stars);
                            } else {
                                localStorage.removeItem(key);
                            }
                        }
                    }
                    if (remainingToConsume <= 0) break;
                }
                
                // æ—¢ç„¶ç¾åœ¨ç›´æ¥æ‰£é™¤é—œå¡æ˜Ÿæ˜Ÿï¼Œæ¸…é™¤èˆŠæœ‰çš„ stars_used ä»¥å…æ··äº‚
                localStorage.removeItem('stars_used');
                
                return remainingToConsume === 0;
            },
            clearAllRecords() {
                const keys = Object.keys(localStorage);
                keys.forEach(key => {
                    if (key.startsWith('level_') || key === 'stars_used') {
                        localStorage.removeItem(key);
                    }
                });
            }
        };

        const GameEngine = {
            state: {
                currentLevel: null,
                difficulty: null,
                questionIndex: 0,
                errors: 0,
                correctCount: 0,
                totalQuestions: 10,
                questions: [],
                isPracticeMode: false
            },

            init() {
                AudioSystem.init();
                UIManager.renderLevelMap();
            },

            startLevel(levelId, difficulty) {
                const level = Levels.find(l => l.id === levelId);
                if (!level) return;

                UIManager.closeModal();

                this.state = {
                    currentLevel: level,
                    difficulty: difficulty,
                    questionIndex: 0,
                    errors: 0,
                    correctCount: 0,
                    totalQuestions: 10,
                    questions: [],
                    isPracticeMode: false
                };

                for (let i = 0; i < this.state.totalQuestions; i++) {
                    this.state.questions.push(level.generateQuestion(difficulty));
                }

                UIManager.showScreen('game');
                UIManager.updateGameUI();
                this.showQuestion();
            },

            startPractice(levelId) {
                const level = PracticeLevels.find(l => l.id === levelId);
                if (!level) return;

                this.state = {
                    currentLevel: level,
                    difficulty: 'practice',
                    questionIndex: 0,
                    errors: 0,
                    correctCount: 0,
                    totalQuestions: Infinity,
                    questions: [],
                    isPracticeMode: true,
                    lastPracticeQuestion: null
                };

                UIManager.showScreen('game');
                UIManager.updatePracticeUI();
                this.generateNewPracticeQuestion();
            },

            showQuestion() {
                const question = this.state.questions[this.state.questionIndex];
                UIManager.renderQuestion(question, (selected, btn) => this.checkAnswer(selected, btn));
            },

            checkAnswer(selected, btnElement) {
                try {
                    const currentQuestion = this.state.isPracticeMode 
                        ? this.state.lastPracticeQuestion
                        : this.state.questions[this.state.questionIndex];
                    
                    if (!currentQuestion) {
                        console.error('Current question is undefined');
                        this.nextQuestion();
                        return;
                    }

                    const isCorrect = selected === currentQuestion.answer;
                    this.handleAnswer(isCorrect, selected, currentQuestion.answer, btnElement);
                } catch (e) {
                    console.error('Error in checkAnswer:', e);
                    this.nextQuestion();
                }
            },

            generateNewPracticeQuestion() {
                try {
                    const question = this.state.currentLevel.generateQuestion(this.state.difficulty);
                    this.state.lastPracticeQuestion = question;
                    UIManager.renderQuestion(question, (selected, btn) => this.checkAnswer(selected, btn));
                } catch (e) {
                    console.error('Error in generateNewPracticeQuestion:', e);
                }
            },

            handleAnswer(isCorrect, selected, correctAnswer, btnElement) {
                try {
                    UIManager.disableAnswerButtons();

                    if (isCorrect) {
                        if (btnElement) btnElement.classList.add('correct');
                        AudioSystem.playCorrect();
                        this.state.correctCount++;
                        
                        setTimeout(() => {
                            this.nextQuestion();
                        }, 1000);
                    } else {
                        if (btnElement) btnElement.classList.add('wrong');
                        AudioSystem.playWrong();
                        this.state.errors++;
                        UIManager.updateErrorCount(this.state.errors);
                        UIManager.highlightCorrectAnswer(correctAnswer);

                        if (!this.state.isPracticeMode && this.state.errors >= 3) {
                            setTimeout(() => this.endGame(), 1000);
                        } else {
                            setTimeout(() => this.nextQuestion(), this.state.isPracticeMode ? 2000 : 1000);
                        }
                    }
                } catch (e) {
                    console.error('Error in handleAnswer:', e);
                    this.nextQuestion();
                }
            },

            nextQuestion() {
                try {
                    this.state.questionIndex++;
                    if (!this.state.isPracticeMode && this.state.questionIndex >= this.state.totalQuestions) {
                        this.endGame();
                    } else {
                        if (this.state.isPracticeMode) {
                            UIManager.updatePracticeUI();
                            this.generateNewPracticeQuestion();
                        } else {
                            UIManager.updateGameUI();
                            this.showQuestion();
                        }
                    }
                } catch (e) {
                    console.error('Error in nextQuestion:', e);
                    this.endGame();
                }
            },

            endGame() {
                try {
                    const stars = this.calculateStars();
                    Storage.saveRecord(this.state.currentLevel.id, this.state.difficulty, stars);
                    UIManager.showResult(stars, this.state.correctCount, this.state.totalQuestions);
                } catch (e) {
                    console.error('Error in endGame:', e);
                    UIManager.showScreen('map');
                }
            },

            calculateStars() {
                if (this.state.errors === 0) return 3;
                if (this.state.errors === 1) return 2;
                if (this.state.errors === 2) return 1;
                return 0;
            },

            retryLevel() {
                UIManager.hideResult();
                this.startLevel(this.state.currentLevel.id, this.state.difficulty);
            },

            backToMap() {
                UIManager.showScreen('map');
            }
        };

        const UIManager = {
            getTotalStars() {
                let total = 0;
                Levels.forEach(level => {
                    total += Storage.getRecord(level.id, 'easy');
                    total += Storage.getRecord(level.id, 'hard');
                });
                return total;
            },

            getAvailableStars() {
                return this.getTotalStars();
            },

            hasThreeStars() {
                let found = false;
                Levels.forEach(level => {
                    if (Storage.getRecord(level.id, 'easy') === 3 || Storage.getRecord(level.id, 'hard') === 3) {
                        found = true;
                    }
                });
                return found;
            },

            renderLevelMap() {
                const mapContainer = document.getElementById('levelMap');
                mapContainer.innerHTML = '';
                Levels.forEach(level => {
                    const easyStars = Storage.getRecord(level.id, 'easy');
                    const hardStars = Storage.getRecord(level.id, 'hard');
                    const card = document.createElement('div');
                    card.className = 'level-card';
                    card.onclick = () => this.openDifficultyModal(level.id);
                    card.innerHTML = `
                        <div class="level-icon">${level.icon}</div>
                        <h3>${level.name}</h3>
                        <div class="level-records">
                            <div class="record-item">
                                <div class="label">ç°¡å–®</div>
                                <div class="stars">${'â­'.repeat(easyStars)}${'â˜†'.repeat(3 - easyStars)}</div>
                            </div>
                            <div class="record-item">
                                <div class="label">å›°é›£</div>
                                <div class="stars">${'â­'.repeat(hardStars)}${'â˜†'.repeat(3 - hardStars)}</div>
                            </div>
                        </div>
                    `;
                    mapContainer.appendChild(card);
                });

                const practiceContainer = document.getElementById('practiceMap');
                practiceContainer.innerHTML = '';
                PracticeLevels.forEach(level => {
                    const card = document.createElement('div');
                    card.className = 'practice-card';
                    card.onclick = () => GameEngine.startPractice(level.id);
                    card.innerHTML = `
                        <div class="practice-icon">${level.icon}</div>
                        <h3>${level.name}</h3>
                        <div class="practice-description">
                            ç„¡é™ç·´ç¿’æ¨¡å¼<br>
                            ğŸ’ª æŒçºŒæŒ‘æˆ°ä¹ä¹ä¹˜æ³•è¡¨ ğŸ’ª<br>
                            <small>ç„¡éŒ¯èª¤é™åˆ¶ â€¢ ç„¡æ™‚é–“å£“åŠ›</small>
                        </div>
                    `;
                    practiceContainer.appendChild(card);
                });

                // æ›´æ–°å¯ç”¨æ˜Ÿæ˜Ÿé¡¯ç¤º
                const starsDisplay = document.getElementById('availableStarsDisplay');
                if (starsDisplay) {
                    const available = this.getAvailableStars();
                    starsDisplay.textContent = `ğŸŒŸ ç•¶å‰å¯ç”¨æ˜Ÿæ˜Ÿ: ${available} ğŸŒŸ`;
                }
            },

            openDifficultyModal(levelId) {
                const level = Levels.find(l => l.id === levelId);
                GameEngine.state.currentLevel = level;
                const modal = document.getElementById('difficultyModal');
                document.getElementById('modalTitle').textContent = `${level.name} - é¸æ“‡é›£åº¦`;
                modal.classList.add('active');
            },

            closeModal() {
                document.getElementById('difficultyModal').classList.remove('active');
            },

            openAdminModal() {
                const modal = document.getElementById('adminGameModal');
                if (modal) modal.classList.add('active');
            },

            closeAdminModal() {
                const modal = document.getElementById('adminGameModal');
                if (modal) modal.classList.remove('active');
            },

            openResultBonusModal() {
                const modal = document.getElementById('resultBonusModal');
                if (modal) modal.classList.add('active');
            },

            closeResultBonusModal() {
                const modal = document.getElementById('resultBonusModal');
                if (modal) modal.classList.remove('active');
            },

            showScreen(screen) {
                const map = document.getElementById('levelMap');
                const practice = document.querySelector('.practice-section');
                const miniGame = document.querySelector('.mini-game-section');
                const reset = document.getElementById('resetSection');
                const title = document.querySelector('.game-title');
                const directBonus = document.getElementById('directBonusSection');
                
                const screens = {
                    'game': document.getElementById('gameScreen'),
                    'result': document.getElementById('resultScreen'),
                    'bonus': document.getElementById('bonusScreen'),
                    'match3': document.getElementById('match3Screen'),
                    'memory': document.getElementById('memoryScreen'),
                    'shooter': document.getElementById('shooterScreen')
                };

                // éš±è—åœ°åœ–ç›¸é—œ
                [map, practice, miniGame, reset, title, directBonus].forEach(el => {
                    if (el) el.style.display = 'none';
                });

                // éš±è—æ‰€æœ‰éŠæˆ²ç•«é¢
                Object.values(screens).forEach(el => {
                    if (el) {
                        el.style.display = 'none';
                        el.classList.remove('active');
                    }
                });

                if (screen === 'map') {
                    map.style.display = 'grid';
                    practice.style.display = 'block';
                    if (miniGame) miniGame.style.display = 'block';
                    if (reset) reset.style.display = 'block';
                    title.style.display = 'block';
                    if (directBonus) directBonus.style.display = 'block';
                    this.renderLevelMap();
                } else if (screens[screen]) {
                    screens[screen].style.display = 'block';
                    screens[screen].classList.add('active');
                }
            },

            updateGameUI() {
                const state = GameEngine.state;
                document.getElementById('levelName').textContent = state.currentLevel.name;
                document.getElementById('questionNumber').textContent = state.questionIndex + 1;
                document.getElementById('totalQuestions').textContent = state.totalQuestions;
                document.getElementById('errorCount').textContent = state.errors;
                
                // Show game elements
                document.getElementById('errorCount').parentElement.style.display = 'block';
                document.getElementById('progressFill').parentElement.style.display = 'block';
                
                const progress = (state.questionIndex / state.totalQuestions) * 100;
                document.getElementById('progressFill').style.width = progress + '%';
            },

            updatePracticeUI() {
                const state = GameEngine.state;
                document.getElementById('levelName').textContent = state.currentLevel.name + ' - ç·´ç¿’æ¨¡å¼';
                document.getElementById('questionNumber').textContent = state.questionIndex + 1;
                document.getElementById('totalQuestions').textContent = 'âˆ';

                // Hide unnecessary elements
                document.getElementById('errorCount').parentElement.style.display = 'none';
                document.getElementById('progressFill').parentElement.style.display = 'none';
            },

            updateErrorCount(count) {
                document.getElementById('errorCount').textContent = count;
            },

            renderQuestion(question, onAnswer) {
                const questionContent = document.getElementById('questionContent');
                const answersContainer = document.getElementById('answersContainer');
                const clockContainer = document.getElementById('clockContainer');

                questionContent.textContent = question.question;
                clockContainer.innerHTML = '';
                answersContainer.innerHTML = '';

                if (question.coinsHtml) {
                    const coinDiv = document.createElement('div');
                    coinDiv.className = 'coin-container';
                    coinDiv.innerHTML = question.coinsHtml;
                    clockContainer.appendChild(coinDiv);
                }

                if (question.isClock) {
                    const clockDiv = document.createElement('div');
                    clockDiv.id = 'clockContainerInner';
                    clockDiv.className = 'clock-canvas';
                    clockContainer.appendChild(clockDiv);
                    drawClock(question.hour, question.minute);
                }

                question.options.forEach(option => {
                    const btn = document.createElement('button');
                    btn.className = 'answer-btn';
                    btn.textContent = option;
                    btn.onclick = () => onAnswer(option, btn);
                    answersContainer.appendChild(btn);
                });
            },

            disableAnswerButtons() {
                document.querySelectorAll('.answer-btn').forEach(btn => {
                    btn.disabled = true;
                    btn.style.cursor = 'not-allowed';
                });
            },

            highlightCorrectAnswer(correctAnswer) {
                document.querySelectorAll('.answer-btn').forEach(btn => {
                    if (btn.textContent === String(correctAnswer)) {
                        btn.classList.add('correct');
                    }
                });
            },

            showResult(stars, correctCount, totalQuestions) {
                this.showScreen('result');
                const resultTitle = document.getElementById('resultTitle');
                const resultStars = document.getElementById('resultStars');
                const resultMessage = document.getElementById('resultMessage');
                const bonusBtn = document.getElementById('bonusBtn');

                if (bonusBtn) {
                    bonusBtn.style.display = stars === 3 ? 'block' : 'none';
                }

                if (stars === 3) {
                    resultTitle.textContent = 'å¤ªæ£’äº†ï¼å®Œç¾éé—œï¼';
                    resultMessage.textContent = `ä½ ç­”å°äº†å…¨éƒ¨ ${totalQuestions} é¡Œï¼`;
                    AudioSystem.playComplete();
                } else if (stars > 0) {
                    resultTitle.textContent = 'åšå¾—å¥½ï¼';
                    resultMessage.textContent = `ä½ ç­”å°äº† ${correctCount} é¡Œï¼Œç¹¼çºŒåŠ æ²¹ï¼`;
                    AudioSystem.playComplete();
                } else {
                    resultTitle.textContent = 'å†æ¥å†å²ï¼';
                    resultMessage.textContent = `é€™æ¬¡ç­”å°äº† ${correctCount} é¡Œï¼Œä¸‹æ¬¡ä¸€å®šæœƒæ›´å¥½ï¼`;
                }
                resultStars.textContent = 'â­'.repeat(stars) + 'â˜†'.repeat(3 - stars);
            },

            hideResult() {
                document.getElementById('resultScreen').classList.remove('active');
            },

            confirmExit() {
                if (confirm('ç¢ºå®šè¦é›¢é–‹éŠæˆ²å—ï¼Ÿé€²åº¦å°‡ä¸æœƒä¿å­˜ã€‚')) {
                    GameEngine.backToMap();
                }
            },

            confirmReset() {
                if (confirm('ç¢ºå®šè¦æ¸…é™¤æ‰€æœ‰ç²å¾—çš„æ˜Ÿæ˜Ÿå—ï¼Ÿé€™é …å‹•ä½œç„¡æ³•å¾©åŸå–”ï¼')) {
                    Storage.clearAllRecords();
                    this.renderLevelMap();
                    alert('å·²æ¸…é™¤æ‰€æœ‰æ˜Ÿæ˜Ÿè¨˜éŒ„ï¼');
                }
            }
        };


        window.onload = () => {
            GameEngine.init();
        };
    </script>
</body>

</html>
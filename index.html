<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>魔法森林數學探險</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft JhengHei', 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        @media (max-width: 600px) {
            .container {
                padding: 10px;
            }
        }

        /* 標題區域 */
        .game-title {
            text-align: center;
            color: white;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .game-title h1 {
            font-size: clamp(28px, 6vw, 48px);
            margin-bottom: 10px;
            animation: titleFloat 3s ease-in-out infinite;
        }

        .coin-tag {
            display: inline-block;
            background: #ffd700;
            color: #8b4513;
            padding: 5px 15px;
            border-radius: 20px;
            margin: 5px;
            font-weight: bold;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.1);
            border: 2px solid #daa520;
        }

        .coin-container {
            margin: 5px 0;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 3px;
            max-width: 100%;
            padding: 5px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 15px;
        }

        .coin-row {
            display: flex;
            flex-wrap: wrap;
            justify-content: flex-start;
            align-items: center;
            width: 100%;
            gap: 2px;
            margin-bottom: 3px;
            padding: 3px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 8px;
        }

        .coin-row-count {
            margin-left: auto;
            font-weight: bold;
            color: #333;
            font-size: clamp(0.8em, 3vw, 1em);
            padding: 1px 6px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 5px;
            min-width: 35px;
            text-align: center;
        }

        .coin-row:last-child {
            margin-bottom: 0;
        }

        .coin-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: rgba(255, 255, 255, 0.8);
            padding: 2px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .coin-img {
            width: clamp(30px, 8vw, 50px);
            height: auto;
            min-height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.2));
        }

        .coin-wrapper.is-bill .coin-img {
            width: clamp(50px, 12vw, 80px);
        }

        .coin-img svg {
            width: 100%;
            height: 100%;
            max-height: 50px;
        }

        .coin-count {
            font-weight: bold;
            color: #333;
            font-size: 1.1em;
        }

        @keyframes titleFloat {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-10px);
            }
        }

        /* 關卡地圖 */
        .level-map {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 25px;
            margin-top: 30px;
        }

        .level-card {
            background: linear-gradient(135deg, #ffffff 0%, #f0f0f0 100%);
            border-radius: 20px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .level-card::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transform: rotate(45deg);
            transition: all 0.5s;
        }

        .level-card:hover::before {
            left: 100%;
        }

        .level-card:hover {
            transform: translateY(-10px) scale(1.02);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.4);
        }

        .level-card h3 {
            font-size: clamp(20px, 4vw, 26px);
            color: #667eea;
            margin-bottom: 15px;
            text-align: center;
        }

        .level-icon {
            font-size: clamp(40px, 8vw, 60px);
            text-align: center;
            margin-bottom: 15px;
        }

        .level-records {
            display: flex;
            justify-content: space-around;
            margin-top: 15px;
            gap: 10px;
        }

        .record-item {
            text-align: center;
            flex: 1;
        }

        .record-item .label {
            font-size: clamp(12px, 2.5vw, 14px);
            color: #666;
            margin-bottom: 5px;
        }

        .stars {
            font-size: clamp(16px, 3.5vw, 20px);
            color: #ffd700;
        }

        /* 練習區域樣式 */
        .practice-section {
            margin-top: 50px;
            padding: clamp(15px, 4vw, 30px);
            background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
            border-radius: 25px;
            box-shadow: 0 15px 35px rgba(255, 154, 158, 0.4);
        }

        .practice-title {
            text-align: center;
            color: white;
            font-size: clamp(24px, 5vw, 32px);
            margin-bottom: 25px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            animation: practiceGlow 2s ease-in-out infinite alternate;
        }

        @keyframes practiceGlow {
            from {
                text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3), 0 0 10px rgba(255, 255, 255, 0.5);
            }

            to {
                text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3), 0 0 20px rgba(255, 255, 255, 0.8);
            }
        }

        .practice-map {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            justify-items: center;
        }

        .practice-card {
            background: linear-gradient(135deg, #ffffff 0%, #f8f9ff 100%);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            border: 3px solid transparent;
            background-clip: padding-box;
            max-width: 400px;
        }

        .practice-card::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255, 204, 0, 0.3), transparent);
            transform: rotate(45deg);
            transition: all 0.5s;
        }

        .practice-card:hover::before {
            left: 100%;
        }

        .practice-card:hover {
            transform: translateY(-10px) scale(1.05);
            box-shadow: 0 20px 50px rgba(255, 154, 158, 0.5);
            border-color: #ffcc00;
        }

        .practice-card h3 {
            font-size: clamp(22px, 4vw, 28px);
            color: #ff6b6b;
            margin-bottom: 15px;
            text-align: center;
            font-weight: bold;
        }

        .practice-icon {
            font-size: clamp(50px, 10vw, 70px);
            text-align: center;
            margin-bottom: 20px;
            animation: practiceFloat 3s ease-in-out infinite;
        }

        @keyframes practiceFloat {

            0%,
            100% {
                transform: translateY(0) rotate(0deg);
            }

            50% {
                transform: translateY(-8px) rotate(5deg);
            }
        }

        .practice-description {
            text-align: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            border-radius: 12px;
            font-size: clamp(14px, 3vw, 16px);
            font-weight: bold;
            margin-top: 15px;
        }

        /* 難度選擇彈窗 */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 25px;
            padding: clamp(15px, 5vw, 30px);
            max-width: 500px;
            width: 100%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            animation: modalSlideIn 0.3s ease;
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-50px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .modal-content h2 {
            color: #667eea;
            text-align: center;
            margin-bottom: 25px;
            font-size: clamp(22px, 5vw, 28px);
        }

        .difficulty-buttons {
            display: flex;
            gap: 15px;
            flex-direction: column;
        }

        .difficulty-btn {
            padding: 20px;
            font-size: clamp(18px, 4vw, 22px);
            border: none;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .difficulty-btn.easy {
            background: linear-gradient(135deg, #84fab0 0%, #8fd3f4 100%);
            color: #2c5f2d;
        }

        .difficulty-btn.hard {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
            color: #8b2500;
        }

        .difficulty-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        }

        .close-modal {
            background: #ccc;
            color: #333;
            margin-top: 15px;
            padding: 12px;
            font-size: clamp(16px, 3.5vw, 18px);
        }

        /* 遊戲畫面 */
        .game-screen {
            display: none;
            background: white;
            border-radius: 25px;
            padding: clamp(15px, 5vw, 40px);
            max-width: 800px;
            margin: 0 auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        .game-screen.active {
            display: block;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 10px;
        }

        @media (max-width: 600px) {
            .game-header {
                justify-content: center;
                text-align: center;
            }

            .game-info {
                justify-content: center;
                width: 100%;
            }
        }

        .game-info {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .info-item {
            font-size: clamp(14px, 3vw, 18px);
            font-weight: bold;
            color: #667eea;
        }

        .back-btn {
            padding: 12px 24px;
            background: #ff6b6b;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: clamp(14px, 3vw, 16px);
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .back-btn:hover {
            background: #ee5a52;
            transform: scale(1.05);
        }

        .reset-container {
            text-align: center;
            margin-top: 30px;
            padding: 20px;
        }

        .reset-btn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.4);
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .reset-btn:hover {
            background: rgba(255, 0, 0, 0.4);
            border-color: #ff6b6b;
        }

        .question-area {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 20px;
            padding: clamp(15px, 4vw, 30px);
            margin-bottom: 20px;
            min-height: 150px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .question-text {
            font-size: clamp(16px, 4vw, 24px);
            color: #333;
            text-align: center;
            margin-bottom: 10px;
            line-height: 1.4;
        }

        /* 時鐘顯示 */
        .clock-canvas {
            width: clamp(150px, 40vw, 250px);
            height: clamp(150px, 40vw, 250px);
            border: 8px solid #333;
            border-radius: 50%;
            position: relative;
            background: white;
            margin: 20px auto;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .clock-center {
            width: 12px;
            height: 12px;
            background: #333;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
        }

        .clock-hand {
            position: absolute;
            bottom: 50%;
            left: 50%;
            transform-origin: bottom center;
            background: #333;
            transition: transform 0.5s cubic-bezier(0.4, 2.08, 0.55, 0.44);
        }

        .hour-hand {
            width: 6px;
            height: 25%;
            background: #333;
            margin-left: -3px;
        }

        .minute-hand {
            width: 4px;
            height: 35%;
            background: #666;
            margin-left: -2px;
        }

        .clock-number {
            position: absolute;
            font-size: clamp(12px, 3vw, 16px);
            font-weight: bold;
            color: #333;
            width: 20px;
            height: 20px;
            text-align: center;
            line-height: 20px;
            margin-top: -10px;
            margin-left: -10px;
            z-index: 5;
        }

        .clock-tick {
            position: absolute;
            top: 0;
            left: 50%;
            transform-origin: bottom center;
            pointer-events: none;
        }

        .clock-tick-inner {
            width: 100%;
            background: #333;
        }

        /* 針對小螢幕進一步壓縮空間 */
        @media (max-width: 600px) {
            .question-area {
                padding: 10px;
                margin-bottom: 10px;
                min-height: 120px;
            }

            .coin-container {
                margin: 2px 0;
                padding: 3px;
            }

            .coin-row {
                margin-bottom: 2px;
                padding: 2px;
            }

            .answers-grid {
                gap: 8px;
                margin-top: 10px;
            }

            .answer-btn {
                padding: 12px 10px;
            }
        }

        .answers-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        .answer-btn {
            padding: clamp(10px, 3vw, 20px);
            font-size: clamp(16px, 3.5vw, 20px);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            min-height: 60px;
        }

        .answer-btn:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        }

        .answer-btn:active {
            transform: translateY(0);
        }

        .answer-btn.correct {
            background: linear-gradient(135deg, #56ab2f 0%, #a8e063 100%);
            animation: correctPulse 0.5s ease;
        }

        .answer-btn.wrong {
            background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%);
            animation: wrongShake 0.5s ease;
        }

        @keyframes correctPulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.1);
            }
        }

        @keyframes wrongShake {

            0%,
            100% {
                transform: translateX(0);
            }

            25% {
                transform: translateX(-10px);
            }

            75% {
                transform: translateX(10px);
            }
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 20px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #56ab2f 0%, #a8e063 100%);
            transition: width 0.3s ease;
        }

        /* 結果畫面 */
        .result-screen {
            display: none;
            background: white;
            border-radius: 25px;
            padding: clamp(20px, 5vw, 40px);
            max-width: 600px;
            margin: 0 auto;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        .result-screen.active {
            display: block;
            animation: modalSlideIn 0.5s ease;
        }

        .result-screen h2 {
            font-size: clamp(28px, 6vw, 36px);
            color: #667eea;
            margin-bottom: 20px;
        }

        .result-stars {
            font-size: clamp(40px, 10vw, 60px);
            margin: 20px 0;
        }

        .result-message {
            font-size: clamp(18px, 4vw, 22px);
            color: #666;
            margin-bottom: 30px;
        }

        .result-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .result-btn {
            padding: 15px 30px;
            font-size: clamp(16px, 3.5vw, 18px);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .retry-btn {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        .home-btn {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
        }

        .result-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        }

        /* 響應式設計 */
        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }

            .level-map {
                grid-template-columns: repeat(2, 1fr);
                gap: 20px;
            }

            .game-header {
                flex-direction: column;
                align-items: flex-start;
            }

            .answers-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .difficulty-buttons {
                gap: 12px;
            }
        }

        @media (min-width: 769px) and (max-width: 1024px) {
            .level-map {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        /* 觸控優化 */
        @media (hover: none) and (pointer: coarse) {

            .answer-btn,
            .difficulty-btn,
            .result-btn,
            .back-btn {
                min-height: 50px;
                padding: 18px;
            }
        }
        /* 獎勵遊戲畫面樣式 */
        #bonusGameContainer {
            touch-action: none;
            user-select: none;
        }

        .falling-star {
            pointer-events: none;
            z-index: 100;
        }

        #basket {
            font-size: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 110;
        }

        @keyframes rainbowStar {
            0% { filter: hue-rotate(0deg) drop-shadow(0 0 8px #fff); }
            100% { filter: hue-rotate(360deg) drop-shadow(0 0 12px #fff); }
        }

        /* 加分/扣分特效樣式 */
        .score-effect {
            position: absolute;
            pointer-events: none;
            font-weight: bold;
            font-size: 24px;
            animation: scoreFloat 0.8s ease-out forwards;
            z-index: 120;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        @keyframes scoreFloat {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-50px) scale(1.5); opacity: 0; }
        }

        .catch-ripple {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            animation: rippleEffect 0.5s ease-out forwards;
            z-index: 115;
        }

        @keyframes rippleEffect {
            0% { width: 0; height: 0; opacity: 0.8; border: 2px solid white; }
            100% { width: 100px; height: 100px; opacity: 0; border: 10px solid white; transform: translate(-50px, -50px); }
        }

        /* 消消樂樣式 */
        .match3-container {
            width: 100%;
            max-width: 550px;
            aspect-ratio: 1;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            border: 4px solid #8b4513;
            border-radius: 15px;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            gap: 2px;
            padding: 5px;
            position: relative;
            background: #2d5a27;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.5);
            touch-action: none;
        }

        .match3-tile {
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(26px, 6.5vw, 38px);
            cursor: pointer;
            transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275), background 0.3s;
            user-select: none;
            position: relative;
        }

        .match3-tile:hover {
            transform: scale(0.95);
            background: #fff;
        }

        .match3-tile.selected {
            background: #fff;
            box-shadow: 0 0 15px #ffd700, inset 0 0 10px #ffd700;
            transform: scale(1.1);
            z-index: 10;
        }

        .match3-tile.match {
            animation: matchPop 0.4s ease-out forwards;
        }

        @keyframes matchPop {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.3); opacity: 1; }
            100% { transform: scale(0); opacity: 0; }
        }

        .match3-tile.falling {
            transition: top 0.3s cubic-bezier(0.55, 0.055, 0.675, 0.19);
        }

        /* 射擊遊戲樣式 */
        .shooter-container {
            position: relative;
            width: 100%;
            height: 520px;
            background: linear-gradient(to bottom, #00111a, #00334d);
            border: 4px solid #0a3d62;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: inset 0 0 25px rgba(0,0,0,0.6);
            touch-action: none;
            cursor: crosshair;
        }
        .shooter-hud {
            position: absolute;
            top: 8px;
            left: 8px;
            color: #fff;
            font-weight: bold;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            z-index: 5;
        }
        .shooter-player, .shooter-bullet, .shooter-enemy, .shooter-explosion {
            position: absolute;
            user-select: none;
            pointer-events: none;
        }
        .shooter-player {
            width: 64px;
            height: 64px;
            transform: translate(-50%, -50%);
            filter: drop-shadow(0 0 8px rgba(255,255,255,0.4));
            font-size: 56px;
            line-height: 1;
        }
        .shooter-bullet {
            width: 8px;
            height: 20px;
            background: #ffeb3b;
            border-radius: 4px;
            box-shadow: 0 0 12px #ffeb3b;
        }
        .shooter-enemy {
            width: 60px;
            height: 60px;
            transform: translate(-50%, -50%);
            filter: drop-shadow(0 0 8px rgba(255,0,0,0.5));
            font-size: 52px;
            line-height: 1;
        }
        .shooter-explosion {
            width: 36px;
            height: 36px;
            border: 4px solid #ffd700;
            border-radius: 50%;
            opacity: 0.9;
            transform: translate(-50%, -50%) scale(0.5);
            transition: transform 0.25s ease-out, opacity 0.25s ease-out;
        }
        /* 3 分怪（👹）特效：發光與脈動放大 */
        @keyframes ogrePulse {
            0% { transform: translate(-50%, -50%) scale(1); box-shadow: 0 0 12px #ff5252, 0 0 24px rgba(255,82,82,0.5); }
            50% { transform: translate(-50%, -50%) scale(1.12); box-shadow: 0 0 18px #ff5252, 0 0 36px rgba(255,82,82,0.7); }
            100% { transform: translate(-50%, -50%) scale(1); box-shadow: 0 0 12px #ff5252, 0 0 24px rgba(255,82,82,0.5); }
        }
        .ogre-boss {
            animation: ogrePulse 1.2s ease-in-out infinite;
            /* 額外高亮：在原本的 drop-shadow 之外再加上盒影暈光 */
            box-shadow: 0 0 14px #ff5252, 0 0 26px rgba(255,82,82,0.6);
        }
        /* 射擊遊戲：分數圖示說明（右上角） */
        .shooter-legend {
            position: absolute;
            top: 8px;
            right: 8px;
            color: #fff;
            background: rgba(0, 0, 0, 0.35);
            border: 1px solid rgba(255,255,255,0.25);
            border-radius: 10px;
            padding: 6px 8px;
            font-size: 14px;
            line-height: 1.2;
            backdrop-filter: blur(2px);
            pointer-events: none; /* 不阻擋射擊/拖曳 */
            z-index: 6;
        }
        .shooter-legend .legend-row { display: flex; align-items: center; gap: 6px; margin: 3px 0; white-space: nowrap; }
        .shooter-legend .icon { width: 22px; text-align: center; font-size: 18px; line-height: 1; filter: drop-shadow(0 0 6px currentColor); }
        .shooter-legend .text { font-weight: 700; text-shadow: 0 2px 3px rgba(0,0,0,0.4); }
        @media (max-width: 480px) { .shooter-legend { font-size: 12px; padding: 5px 6px; } .shooter-legend .icon { font-size: 16px; width: 18px; } }

        /* 記憶遊戲樣式 */
        .memory-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            max-width: 600px;
            margin: 0 auto;
            perspective: 1000px;
        }

        @media (max-width: 600px) {
            .memory-grid {
                grid-template-columns: repeat(4, 1fr);
                gap: 5px;
            }
        }

        .memory-card {
            aspect-ratio: 3/4;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
        }

        .memory-card.flipped {
            transform: rotateY(180deg);
        }

        .memory-card.matched {
            animation: matchSuccess 0.5s ease-out forwards;
        }

        @keyframes matchSuccess {
            0% { transform: rotateY(180deg) scale(1); filter: brightness(1); opacity: 1; }
            50% { transform: rotateY(180deg) scale(1.1); filter: brightness(1.5); box-shadow: 0 0 20px #ffd700; opacity: 1; }
            100% { transform: rotateY(180deg) scale(0); filter: brightness(0.8); opacity: 0; }
        }

        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(32px, 8vw, 50px);
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .card-front {
            background: linear-gradient(135deg, #a1c4fd 0%, #c2e9fb 100%);
            transform: rotateY(180deg);
        }

        .card-back {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: 2px solid white;
        }

        .card-back::after {
            content: '🌳';
            font-size: 1.2em;
        }

        /* 平板橫向優化：記憶卡片改為橫向排列與比例 */
        @media (orientation: landscape) and (min-width: 768px) and (max-width: 1199px) {
            .memory-grid {
                grid-template-columns: repeat(6, 1fr); /* 6 欄 x 4 列 = 24 張卡片，較適合橫向 */
                max-width: 900px;
                gap: 12px;
            }
            .memory-card {
                aspect-ratio: 4 / 3; /* 改為橫向比例 */
            }
            .card-face {
                font-size: clamp(28px, 6vw, 48px); /* 調整字體避免過大 */
            }
        }

        /* 大螢幕橫向（桌機橫放或大型平板）可再放寬一點 */
        @media (orientation: landscape) and (min-width: 1200px) {
            .memory-grid {
                grid-template-columns: repeat(6, 1fr);
                max-width: 1000px;
                gap: 14px;
            }
            .memory-card { aspect-ratio: 4 / 3; }
        }

        /* 森林切切樂 遊戲樣式 */
        .fruit-container {
            position: relative;
            width: 100%;
            height: min(62vh, 520px);
            background: linear-gradient(180deg, rgba(0,0,0,0.1), rgba(0,0,0,0.15));
            border-radius: 16px;
            overflow: hidden;
            box-shadow: inset 0 0 30px rgba(0,0,0,0.25);
            touch-action: none; /* 讓觸控可自由畫線 */
            user-select: none;
        }
        .fruit {
            position: absolute;
            width: 96px;
            height: 96px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 64px;
            transform: translate(-50%, -50%);
            filter: drop-shadow(0 8px 14px rgba(0,0,0,0.38));
            transition: transform 0.15s ease;
            will-change: transform, opacity;
        }
        .fruit.sliced {
            opacity: 0.6;
            transform: translate(-50%, -50%) scale(0.85) rotate(10deg);
        }
        .slice-trail {
            position: absolute;
            width: 10px; height: 10px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,255,255,0.95) 0%, rgba(255,255,255,0.3) 60%, rgba(255,255,255,0) 70%);
            pointer-events: none;
            filter: drop-shadow(0 0 6px rgba(255,255,255,0.6));
            animation: fadeTrail 0.45s ease-out forwards;
        }
        @keyframes fadeTrail {
            0% { opacity: 0.9; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.6); }
        }
        /* 切水果：切開動畫用的左右半邊與果汁濺射 */
        .fruit-piece {
            position: absolute;
            width: 96px;
            height: 96px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 64px;
            transform: translate(-50%, -50%);
            pointer-events: none;
            filter: drop-shadow(0 8px 14px rgba(0,0,0,0.38));
            will-change: transform, opacity;
        }
        .fruit-piece.left { clip-path: inset(0 50% 0 0); }
        .fruit-piece.right { clip-path: inset(0 0 0 50%); }
        .fruit-piece.left { animation: flyLeft 550ms ease-out forwards; }
        .fruit-piece.right { animation: flyRight 550ms ease-out forwards; }
        @keyframes flyLeft {
            0% { opacity: 1; transform: translate(-50%, -50%) rotate(0deg); }
            60% { opacity: 1; transform: translate(calc(-50% - 30px), calc(-50% - 10px)) rotate(-18deg); }
            100% { opacity: 0; transform: translate(calc(-50% - 60px), calc(-50% + 40px)) rotate(-38deg); }
        }
        @keyframes flyRight {
            0% { opacity: 1; transform: translate(-50%, -50%) rotate(0deg); }
            60% { opacity: 1; transform: translate(calc(-50% + 30px), calc(-50% - 10px)) rotate(18deg); }
            100% { opacity: 0; transform: translate(calc(-50% + 60px), calc(-50% + 40px)) rotate(38deg); }
        }
        .fruit-juice {
            position: absolute;
            width: 20px; height: 20px;
            border-radius: 50%;
            pointer-events: none;
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.9), rgba(255,80,80,0.8) 40%, rgba(255,0,0,0.0) 70%);
            filter: blur(0.5px) drop-shadow(0 0 10px rgba(255,80,80,0.6));
            transform: translate(-50%, -50%) scale(1);
            animation: juicePop 600ms ease-out forwards;
        }
        @keyframes juicePop {
            0% { opacity: 0.9; transform: translate(-50%, -50%) scale(0.6); }
            60% { opacity: 0.8; transform: translate(-50%, -50%) scale(1.6); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(2.2); }
        }

        /* 平板直向：確保24張卡片能在單一畫面顯示（4欄 x 6列）*/
        @media (orientation: portrait) and (min-width: 768px) and (max-width: 1199px) {
            #memoryScreen { overflow: hidden; }
            #memoryScreen > p { display: none; } /* 隱藏提示文字以節省垂直空間 */
            .memory-grid {
                /* 仍然是4欄排列，但縮放以保證6列在可視高度內 */
                grid-template-columns: repeat(4, 1fr);
                gap: 8px;
                max-width: none; /* 使用計算寬度以符合高度 */
                /* 預留上方標題/按鈕等UI高度，避免需要捲動 */
                --ui-reserve: 240px;
                width: min(
                    95vw,
                    calc( ((((100vh - var(--ui-reserve)) - (5 * 8px)) / 6) * (3 / 4) * 4) + (3 * 8px) )
                );
                margin-left: auto;
                margin-right: auto;
            }
            .memory-card {
                aspect-ratio: 3 / 4; /* 直向比例，便於在縱向螢幕排6列 */
            }
            .card-face {
                font-size: clamp(22px, 5.2vw, 40px);
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <!-- 遊戲標題 -->
        <div class="game-title">
            <h1>🌳 魔法森林數學探險 🌳</h1>
            <p>選擇關卡開始冒險吧！</p>
        </div>

        <!-- 關卡地圖 -->
        <div id="levelMap" class="level-map"></div>

        <!-- 練習區域 -->
        <div class="practice-section">
            <h2 class="practice-title">🔥 特別練習區 🔥</h2>
            <div id="practiceMap" class="practice-map"></div>
        </div>

        <!-- 迷你遊戲區 -->
        <div class="mini-game-section" style="margin-top: 30px;">
            <div id="availableStarsDisplay" style="text-align: center; margin-bottom: 10px; color: #ffd700; font-weight: bold; font-size: 1.2em; text-shadow: 1px 1px 2px rgba(0,0,0,0.5);"></div>
            <h2 class="practice-title">🎮 迷你遊戲區 🎮</h2>
            <div class="practice-map">
                <div class="practice-card" onclick="Match3Game.start()" style="position: relative;">
                    <div style="position: absolute; top: 10px; right: 10px; background: #ff4d4d; color: white; padding: 2px 8px; border-radius: 10px; font-size: 0.8em; font-weight: bold; box-shadow: 0 2px 4px rgba(0,0,0,0.2);">
                        一次 3 ⭐
                    </div>
                    <div class="practice-icon">🍓</div>
                    <h3>森林消消樂</h3>
                    <div class="practice-description">
                        放鬆一下！<br>
                        🍎 將三個相同的水果連在一起消除吧 🍇<br>
                        <small>益智休閒 • 森林主題</small>
                    </div>
                </div>
                <div class="practice-card" onclick="MemoryGame.start()" style="position: relative;">
                    <div style="position: absolute; top: 10px; right: 10px; background: #ff4d4d; color: white; padding: 2px 8px; border-radius: 10px; font-size: 0.8em; font-weight: bold; box-shadow: 0 2px 4px rgba(0,0,0,0.2);">
                        一次 3 ⭐
                    </div>
                    <div class="practice-icon">🧠</div>
                    <h3>森林記憶王</h3>
                    <div class="practice-description">
                        腦力大考驗！<br>
                        🔍 找出兩兩成對的森林夥伴吧 🦉<br>
                        <small>記憶訓練 • 24–36張卡片</small>
                    </div>
                </div>
                <div class="practice-card" onclick="FruitGame.start()" style="position: relative;">
                    <div style="position: absolute; top: 10px; right: 10px; background: #ff4d4d; color: white; padding: 2px 8px; border-radius: 10px; font-size: 0.8em; font-weight: bold; box-shadow: 0 2px 4px rgba(0,0,0,0.2);">
                        一次 3 ⭐
                    </div>
                    <div class="practice-icon">🍉</div>
                    <h3>森林切切樂</h3>
                    <div class="practice-description">
                        反應力挑戰！<br>
                        ✂️ 用手指或滑鼠劃過水果來切開得分！<br>
                        <small>動作休閒 • 目標 100 分</small>
                    </div>
                </div>
            </div>
        </div>

        <!-- 重置進度區域 -->
        <div id="resetSection" class="reset-container">
            <button class="reset-btn" onclick="UIManager.confirmReset()">🗑️ 清除所有星星記錄</button>
        </div>

        <!-- 直接進入通關後小遊戲（移至頁面最下方） -->
        <div id="directBonusSection" style="margin: 20px 0 10px; text-align: center;">
            <button onclick="SecureBonus.promptAndStart()" style="background: linear-gradient(135deg, #ffd700 0%, #ff8c00 100%); color: white; border: none; padding: 12px 18px; border-radius: 12px; font-size: 1.05em; font-weight: bold; box-shadow: 0 4px 10px rgba(0,0,0,0.2); cursor: pointer;">
                管理者設定
            </button>
        </div>

        <!-- 難度選擇彈窗 -->
        <div id="difficultyModal" class="modal">
            <div class="modal-content">
                <h2 id="modalTitle">選擇難度</h2>
                <div class="difficulty-buttons">
                    <button class="difficulty-btn easy" onclick="GameEngine.startLevel(GameEngine.state.currentLevel.id, 'easy')">
                        🌱 簡單模式
                    </button>
                    <button class="difficulty-btn hard" onclick="GameEngine.startLevel(GameEngine.state.currentLevel.id, 'hard')">
                        🔥 困難模式
                    </button>
                    <button class="difficulty-btn close-modal" onclick="UIManager.closeModal()">
                        取消
                    </button>
                </div>
            </div>
        </div>

        <!-- 管理者遊戲入口彈窗 -->
        <div id="adminGameModal" class="modal">
            <div class="modal-content">
                <h2>管理者設定</h2>
                <div style="margin-bottom:8px; font-weight:bold; color:#2e7d32;">🏆 通關後小遊戲</div>
                <div class="difficulty-buttons" style="margin-bottom:14px;">
                    <button class="difficulty-btn" style="background: linear-gradient(135deg,#ffd700,#ff8c00); color:#fff;" onclick="UIManager.closeAdminModal(); BonusGame.start(true)">🌟 星星收集大作戰</button>
                    <button class="difficulty-btn" onclick="UIManager.closeAdminModal(); ShootingGame.start(true)">🎯 森林射擊戰</button>
                </div>
                <div style="margin:10px 0 8px; font-weight:bold; color:#1565c0;">🎮 迷你遊戲區</div>
                <div class="difficulty-buttons" style="margin-bottom:14px;">
                    <button class="difficulty-btn" onclick="UIManager.closeAdminModal(); Match3Game.start(true)">🍓 森林消消樂</button>
                    <button class="difficulty-btn" onclick="UIManager.closeAdminModal(); MemoryGame.start(true)">🧠 森林記憶王</button>
                    <button class="difficulty-btn" onclick="UIManager.closeAdminModal(); FruitGame.start(true)">🍉 森林切切樂</button>
                </div>
                <div style="margin:10px 0 8px; font-weight:bold; color:#6d4c41;">🌟 星星管理</div>
                <div style="font-size:0.95em; color:#444; margin:6px 0 10px;">
                    目前星星：<b id="adminStarsCurrent">0</b> 顆 ｜ 調整：<b id="adminStarsDelta">0</b> 顆 ｜ 調整後：<b id="adminStarsAfter">0</b>/<span id="adminStarsMax">36</span> 顆
                </div>
                <div style="display:flex; gap:8px; align-items:center; margin-bottom:8px;">
                    <input id="adminAddStarsInput" type="number" value="0" oninput="UIManager.adminUpdateStarPreview()" style="flex:1; padding:10px 12px; border-radius:10px; border:1px solid #ccc;" placeholder="可輸入正負數，例如 3 或 -3">
                    <button class="difficulty-btn" style="flex:0 0 auto; padding:10px 12px;" onclick="UIManager.adminQuickAdd(1)">+1</button>
                    <button class="difficulty-btn" style="flex:0 0 auto; padding:10px 12px;" onclick="UIManager.adminQuickAdd(3)">+3</button>
                    <button class="difficulty-btn" style="flex:0 0 auto; padding:10px 12px;" onclick="UIManager.adminQuickAdd(5)">+5</button>
                </div>
                <div style="display:flex; gap:8px; align-items:center; margin-bottom:10px;">
                    <div style="flex:1"></div>
                    <button class="difficulty-btn" style="flex:0 0 auto; padding:10px 12px;" onclick="UIManager.adminQuickAdd(-1)">-1</button>
                    <button class="difficulty-btn" style="flex:0 0 auto; padding:10px 12px;" onclick="UIManager.adminQuickAdd(-3)">-3</button>
                    <button class="difficulty-btn" style="flex:0 0 auto; padding:10px 12px;" onclick="UIManager.adminQuickAdd(-5)">-5</button>
                </div>
                <div class="difficulty-buttons">
                    <button class="difficulty-btn" style="background: linear-gradient(135deg,#66bb6a,#43a047); color:#fff;" onclick="UIManager.adminApplyStars()">套用調整並回首頁</button>
                    <button class="difficulty-btn close-modal" onclick="UIManager.closeAdminModal()">關閉</button>
                </div>
            </div>
        </div>

        <!-- 通關後小遊戲選擇彈窗（結果畫面 3 星時開啟） -->
        <div id="resultBonusModal" class="modal">
            <div class="modal-content">
                <h2>選擇通關後小遊戲</h2>
                <div class="difficulty-buttons">
                    <button class="difficulty-btn" style="background: linear-gradient(135deg,#ffd700,#ff8c00); color:#fff;" onclick="UIManager.closeResultBonusModal(); BonusGame.start(true)">🌟 星星收集大作戰</button>
                    <button class="difficulty-btn" onclick="UIManager.closeResultBonusModal(); ShootingGame.start()">🎯 森林射擊戰</button>
                    <button class="difficulty-btn close-modal" onclick="UIManager.closeResultBonusModal()">關閉</button>
                </div>
            </div>
        </div>

        <!-- 管理者密碼彈窗（隱藏輸入文字） -->
        <div id="adminPasswordModal" class="modal" aria-hidden="true">
            <div class="modal-content">
                <h2>輸入密碼</h2>
                <div style="margin: 10px 0 15px;">
                    <input id="adminPasswordInput" type="password" placeholder="請輸入密碼" style="width: 100%; padding: 12px 14px; font-size: 1em; border-radius: 10px; border: 1px solid #ccc; outline: none;">
                </div>
                <div id="adminPasswordError" style="display:none; color:#b00020; font-size:0.95em; margin-bottom:10px;">密碼錯誤，請再試一次！</div>
                <div class="difficulty-buttons">
                    <button class="difficulty-btn" onclick="SecureBonus.submitPassword()">確認</button>
                    <button class="difficulty-btn close-modal" onclick="SecureBonus.closeModal()">取消</button>
                </div>
            </div>
        </div>

        <!-- 遊戲畫面 -->
        <div id="gameScreen" class="game-screen">
            <div class="game-header">
                <div class="game-info">
                    <div class="info-item">
                        <span id="levelName">關卡名稱</span>
                    </div>
                    <div class="info-item">
                        題目: <span id="questionNumber">1</span>/<span id="totalQuestions">10</span>
                    </div>
                    <div class="info-item">
                        錯誤: <span id="errorCount">0</span>/3
                    </div>
                </div>
                <button class="back-btn" onclick="UIManager.confirmExit()">返回地圖</button>
            </div>

            <div class="progress-bar">
                <div id="progressFill" class="progress-fill" style="width: 0%"></div>
            </div>

            <div class="question-area">
                <div id="questionContent" class="question-text"></div>
                <div id="clockContainer"></div>
            </div>

            <div id="answersContainer" class="answers-grid"></div>
        </div>

        <!-- 結果畫面 -->
        <div id="resultScreen" class="result-screen">
            <h2 id="resultTitle">恭喜完成！</h2>
            <div id="resultStars" class="result-stars"></div>
            <div id="resultMessage" class="result-message"></div>
            <div class="result-buttons">
                <button id="bonusBtn" class="result-btn" style="display: none; background: linear-gradient(135deg, #ffd700 0%, #ff8c00 100%); color: white; width: 100%; margin-bottom: 10px;" onclick="UIManager.openResultBonusModal()">🌟 進入小遊戲獎勵 🌟</button>
                <button class="result-btn retry-btn" onclick="GameEngine.retryLevel()">再玩一次</button>
                <button class="result-btn home-btn" onclick="GameEngine.backToMap()">返回地圖</button>
            </div>
        </div>

        <!-- 獎勵遊戲畫面 -->
        <div id="bonusScreen" class="game-screen">
            <div class="game-header">
                <div class="game-info">
                    <div class="info-item">星星收集大作戰</div>
                    <div class="info-item">得分: <span id="bonusScore">0</span></div>
                </div>
                <button class="back-btn" onclick="BonusGame.stop()">結束遊戲</button>
            </div>
            <div id="bonusGameContainer" style="position: relative; width: 100%; height: 400px; background: linear-gradient(to bottom, #1a2a6c, #b21f1f, #fdbb2d); overflow: hidden; border-radius: 15px; cursor: crosshair;">
                <!-- 遊戲元素將由 JS 動態生成 -->
            </div>
            <p style="text-align: center; margin-top: 10px; color: #666;">移動籃子接住掉落的星星吧！</p>
        </div>

        <!-- 消消樂遊戲畫面 -->
        <div id="match3Screen" class="game-screen">
            <div class="game-header">
                <div class="game-info">
                    <div class="info-item">森林消消樂</div>
                    <div class="info-item">得分: <span id="match3Score">0</span></div>
                </div>
                <button class="back-btn" onclick="Match3Game.stop()">返回地圖</button>
            </div>
            <div id="match3Container" class="match3-container">
                <!-- 網格將由 JS 動態生成 -->
            </div>
            <p style="text-align: center; margin-top: 10px; color: #666;">點擊兩個相鄰的水果來交換位置！</p>
        </div>

        <!-- 射擊遊戲畫面 -->
        <div id="shooterScreen" class="game-screen">
            <div class="game-header">
                <div class="game-info">
                    <div class="info-item">森林射擊戰</div>
                    <div class="info-item">得分: <span id="shooterScore">0</span></div>
                </div>
                <button class="back-btn" onclick="ShootingGame.stop()">返回地圖</button>
            </div>
            <div id="shooterContainer" class="shooter-container">
                <div class="shooter-hud">W/A/S/D 或拖曳移動，點擊/空白鍵射擊</div>
            </div>
            <p style="text-align:center; margin-top:10px; color:#666;">消滅森林中的搗蛋幽靈吧！</p>
        </div>

        <!-- 記憶遊戲畫面 -->
        <div id="memoryScreen" class="game-screen">
            <div class="game-header">
                <div class="game-info">
                    <div class="info-item">森林記憶王</div>
                    <div class="info-item">配對: <span id="memoryPairs">0</span>/<span id="memoryTotalPairs">12</span></div>
                </div>
                <button class="back-btn" onclick="MemoryGame.stop()">返回地圖</button>
            </div>
            <div id="memoryGrid" class="memory-grid">
                <!-- 卡片將由 JS 動態生成 -->
            </div>
            <p style="text-align: center; margin-top: 10px; color: #666;">找出兩兩成對的卡片吧！</p>
        </div>

        <!-- 森林切切樂遊戲畫面 -->
        <div id="fruitScreen" class="game-screen">
            <div class="game-header">
                <div class="game-info">
                    <div class="info-item">森林切切樂</div>
                    <div class="info-item">得分: <span id="fruitScore">0</span></div>
                </div>
                <button class="back-btn" onclick="FruitGame.stop()">返回地圖</button>
            </div>
            <div id="fruitContainer" class="fruit-container">
                <!-- 水果與滑軌由 JS 動態生成 -->
            </div>
            <p style="text-align: center; margin-top: 10px; color: #666;">用手指或滑鼠快速劃過水果來切開它們！累積 100 分過關。</p>
        </div>
    </div>

    <script>
        // 獎勵小遊戲邏輯
        const BonusGame = {
            score: 0,
            gameActive: false,
            stars: [],
            basketPos: 50,
            animationId: null,
            spawnTimer: null,

            start(bypassUnlock = false) {
                const unlocked = bypassUnlock || UIManager.hasThreeStars();
                if (!unlocked) {
                    alert(`🌟 在任一關卡獲得 3 顆星星即可解鎖獎勵遊戲喔！繼續加油！`);
                    return;
                }

                this.score = 0;
                this.gameActive = true;
                this.stars = [];
                this.basketPos = 50;
                
                UIManager.showScreen('bonus');
                this.initUI();
                this.gameLoop();
                this.spawnStar();
            },

            stop() {
                this.gameActive = false;
                cancelAnimationFrame(this.animationId);
                clearTimeout(this.spawnTimer);
                UIManager.showScreen('map');
            },

            winGame() {
                if (!this.gameActive) return;
                this.gameActive = false;
                cancelAnimationFrame(this.animationId);
                clearTimeout(this.spawnTimer);
                
                // 播放勝利音效
                AudioSystem.playComplete();
                
                // 清理剩餘星星
                const container = document.getElementById('bonusGameContainer');
                if (container) {
                    const stars = container.querySelectorAll('.falling-star');
                    stars.forEach(s => s.remove());
                    
                    // 建立過關畫面層
                    const winOverlay = document.createElement('div');
                    winOverlay.id = 'winOverlay';
                    winOverlay.style.cssText = `
                        position: absolute;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: rgba(0, 0, 0, 0.8);
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                        justify-content: center;
                        color: white;
                        z-index: 200;
                        animation: modalSlideIn 0.5s ease;
                        text-align: center;
                        padding: 20px;
                    `;
                    
                    winOverlay.innerHTML = `
                        <h2 style="font-size: clamp(28px, 6vw, 40px); color: #ffd700; margin-bottom: 15px; text-shadow: 0 0 10px rgba(255,215,0,0.5);">🎊 恭喜過關 🎊</h2>
                        <div style="font-size: 60px; margin-bottom: 15px;">⭐⭐⭐</div>
                        <p style="font-size: clamp(18px, 4vw, 22px); margin-bottom: 25px;">太厲害了！你收集滿 100 分了！<br>你是真正的星星收集大師！</p>
                        <button class="result-btn home-btn" style="min-width: 200px;" onclick="BonusGame.stop()">返回地圖</button>
                    `;
                    container.appendChild(winOverlay);
                }
            },

            initUI() {
                const container = document.getElementById('bonusGameContainer');
                container.innerHTML = `
                    <div id="basket" style="position: absolute; bottom: 10px; left: 50%; width: 80px; height: 50px; transform: translateX(-50%); transition: left 0.05s linear; cursor: pointer;">🧺</div>
                `;
                document.getElementById('bonusScore').textContent = '0';

                const handleMove = (e) => {
                    if (!this.gameActive) return;
                    const rect = container.getBoundingClientRect();
                    let clientX;
                    if (e.touches && e.touches.length > 0) {
                        clientX = e.touches[0].clientX;
                    } else {
                        clientX = e.clientX;
                    }
                    const x = clientX - rect.left;
                    this.basketPos = Math.max(5, Math.min(95, (x / rect.width) * 100));
                    const basket = document.getElementById('basket');
                    if (basket) basket.style.left = this.basketPos + '%';
                };

                container.onmousemove = handleMove;
                container.ontouchmove = (e) => {
                    handleMove(e);
                    if (e.cancelable) e.preventDefault();
                };
            },

            spawnStar() {
                if (!this.gameActive) return;
                
                const id = Date.now() + Math.random();
                const rand = Math.random();
                
                // 定義不同類型的掉落物
                // 黃色星星: 70%, 紅色星星: 15%, 彩色星星: 5%, 炸彈: 10%
                let typeConfig = { 
                    icon: '★', 
                    score: 1, 
                    style: 'color: #ffd700; filter: drop-shadow(0 0 2px rgba(0,0,0,0.5));' 
                };

                if (rand < 0.05) { // 彩色星星 (3分)
                    typeConfig = { 
                        icon: '★', 
                        score: 3, 
                        style: 'color: #ff00ea; animation: rainbowStar 0.8s linear infinite;' 
                    };
                } else if (rand < 0.20) { // 紅色星星 (2分)
                    typeConfig = { 
                        icon: '★', 
                        score: 2, 
                        style: 'color: #ff0000; filter: drop-shadow(0 0 3px rgba(255,255,255,0.8));' 
                    };
                } else if (rand < 0.30) { // 炸彈 (-1分)
                    typeConfig = { 
                        icon: '💣', 
                        score: -1, 
                        style: '' 
                    };
                }

                const star = {
                    id: id,
                    x: Math.random() * 90 + 5,
                    y: -40,
                    speed: Math.random() * 3 + 2,
                    score: typeConfig.score
                };
                this.stars.push(star);
                
                const starEl = document.createElement('div');
                starEl.id = `star-${id}`;
                starEl.className = 'falling-star';
                starEl.style.position = 'absolute';
                starEl.style.left = star.x + '%';
                starEl.style.top = star.y + 'px';
                starEl.innerHTML = `<span style="${typeConfig.style}">${typeConfig.icon}</span>`;
                starEl.style.fontSize = '35px';
                document.getElementById('bonusGameContainer').appendChild(starEl);

                this.spawnTimer = setTimeout(() => this.spawnStar(), 800);
            },

            gameLoop() {
                if (!this.gameActive) return;

                const container = document.getElementById('bonusGameContainer');
                if (!container) {
                    this.stop();
                    return;
                }
                const containerHeight = container.offsetHeight || 400;

                for (let i = this.stars.length - 1; i >= 0; i--) {
                    const star = this.stars[i];
                    star.y += star.speed;
                    
                    const starEl = document.getElementById(`star-${star.id}`);
                    if (starEl) {
                        starEl.style.top = star.y + 'px';

                        // 碰撞檢測
                        if (star.y > containerHeight - 80 && star.y < containerHeight - 30) {
                            if (Math.abs(star.x - this.basketPos) < 10) {
                                this.score += star.score;
                                if (this.score < 0) this.score = 0; // 分數不低於 0
                                
                                const scoreEl = document.getElementById('bonusScore');
                                if (scoreEl) scoreEl.textContent = this.score;
                                this.createCatchEffect(star.x, star.y, star.score);
                                starEl.remove();
                                this.stars.splice(i, 1);
                                
                                if (star.score > 0) {
                                    AudioSystem.playCorrect();
                                    const basket = document.getElementById('basket');
                                    if (basket) {
                                        basket.style.filter = 'brightness(1.2) drop-shadow(0 0 10px #ffd700)';
                                        setTimeout(() => { if (basket && basket.style) basket.style.filter = ''; }, 200);
                                    }

                                    // 檢查是否達到 100 分
                                    if (this.score >= 100) {
                                        setTimeout(() => this.winGame(), 200);
                                        return;
                                    }
                                } else {
                                    AudioSystem.playWrong();
                                    const basket = document.getElementById('basket');
                                    if (basket) {
                                        basket.style.filter = 'brightness(1.5) drop-shadow(0 0 10px #ff0000)';
                                        setTimeout(() => { if (basket && basket.style) basket.style.filter = ''; }, 300);
                                    }
                                }
                                continue;
                            }
                        }

                        if (star.y > containerHeight) {
                            starEl.remove();
                            this.stars.splice(i, 1);
                        }
                    } else {
                        // 如果元素消失了但資料還在，也清理掉
                        this.stars.splice(i, 1);
                    }
                }

                this.animationId = requestAnimationFrame(() => this.gameLoop());
            },

            createCatchEffect(x, y, score) {
                const container = document.getElementById('bonusGameContainer');
                if (!container) return;

                // 分數浮動文字
                const effect = document.createElement('div');
                effect.className = 'score-effect';
                effect.style.left = x + '%';
                effect.style.top = y + 'px';
                effect.style.transform = 'translateX(-50%)';
                
                if (score > 0) {
                    effect.textContent = `+${score}`;
                    effect.style.color = '#ffff00';
                } else {
                    effect.innerHTML = '💥 -1';
                    effect.style.color = '#ff4d4d';
                    effect.style.fontSize = '32px';
                }
                
                container.appendChild(effect);
                
                // 擴散漣漪效果
                const ripple = document.createElement('div');
                ripple.className = 'catch-ripple';
                ripple.style.left = x + '%';
                ripple.style.top = y + 'px';
                if (score < 0) {
                    ripple.style.borderColor = '#ff0000';
                    ripple.style.borderWidth = '4px';
                }
                container.appendChild(ripple);

                // 自動清理
                setTimeout(() => {
                    if (effect.parentNode) effect.remove();
                    if (ripple.parentNode) ripple.remove();
                }, 1000);
            }
        };

        // 管理者密碼驗證（改為自訂彈窗，輸入內容隱藏）
        const SecureBonus = {
            promptAndStart() {
                // 開啟自訂密碼彈窗
                const modal = document.getElementById('adminPasswordModal');
                const input = document.getElementById('adminPasswordInput');
                const error = document.getElementById('adminPasswordError');
                if (error) error.style.display = 'none';
                if (input) {
                    input.value = '';
                    modal.classList.add('active');
                    setTimeout(() => input.focus(), 50);
                    input.onkeydown = (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            this.submitPassword();
                        } else if (e.key === 'Escape') {
                            e.preventDefault();
                            this.closeModal();
                        }
                    };
                }
            },
            getTodayPassword() {
                const today = new Date();
                const yyyy = String(today.getFullYear());
                const mm = String(today.getMonth() + 1).padStart(2, '0');
                const dd = String(today.getDate()).padStart(2, '0');
                return `${yyyy}${mm}${dd}`;
            },
            submitPassword() {
                try {
                    const input = document.getElementById('adminPasswordInput');
                    const error = document.getElementById('adminPasswordError');
                    const value = (input.value || '').trim();
                    const password = this.getTodayPassword();
                    if (value === password) {
                        this.closeModal();
                        UIManager.openAdminModal();
                    } else {
                        if (error) error.style.display = 'block';
                        input.focus();
                        input.select && input.select();
                    }
                } catch (e) {
                    console.error('Password submit error:', e);
                    alert('出現問題，請稍後再試。');
                }
            },
            closeModal() {
                const modal = document.getElementById('adminPasswordModal');
                if (modal) modal.classList.remove('active');
            }
        };

        // 消消樂遊戲邏輯
        const Match3Game = {
            gridSize: 8,
            items: ['🍎', '🍇', '🍊', '🍓', '🥝', '🍋'],
            grid: [],
            score: 0,
            selectedTile: null,
            isProcessing: false,

            start(bypass = false) {
                if (!bypass) {
                    const available = UIManager.getAvailableStars();
                    if (available < 3) {
                        alert(`🌟 需要 3 顆可用星星才能玩「森林消消樂」喔！\n趕快去挑戰關卡賺取星星吧！`);
                        return;
                    }

                    if (!confirm(`確定要花費 3 顆星星開始「森林消消樂」嗎？`)) {
                        return;
                    }
                    if (!Storage.consumeStarsSequentially(3)) {
                        return;
                    }
                    UIManager.renderLevelMap();
                }

                this.score = 0;
                this.isProcessing = false;
                this.selectedTile = null;
                UIManager.showScreen('match3');
                this.initGrid();
                this.renderGrid();
                document.getElementById('match3Score').textContent = '0';
            },

            stop() {
                UIManager.showScreen('map');
            },

            initGrid() {
                this.grid = [];
                for (let r = 0; r < this.gridSize; r++) {
                    this.grid[r] = [];
                    for (let c = 0; c < this.gridSize; c++) {
                        let item;
                        do {
                            item = this.items[Math.floor(Math.random() * this.items.length)];
                        } while (this.isInitialMatch(r, c, item));
                        this.grid[r][c] = item;
                    }
                }
            },

            isInitialMatch(r, c, item) {
                if (r >= 2 && this.grid[r-1][c] === item && this.grid[r-2][c] === item) return true;
                if (c >= 2 && this.grid[r][c-1] === item && this.grid[r][c-2] === item) return true;
                return false;
            },

            renderGrid() {
                const container = document.getElementById('match3Container');
                container.innerHTML = '';
                for (let r = 0; r < this.gridSize; r++) {
                    for (let c = 0; c < this.gridSize; c++) {
                        const tile = document.createElement('div');
                        tile.className = 'match3-tile';
                        tile.textContent = this.grid[r][c];
                        tile.dataset.row = r;
                        tile.dataset.col = c;
                        tile.onclick = (e) => this.handleTileClick(r, c, tile);
                        container.appendChild(tile);
                    }
                }
            },

            handleTileClick(r, c, tileEl) {
                if (this.isProcessing) return;

                if (!this.selectedTile) {
                    this.selectedTile = { r, c, el: tileEl };
                    tileEl.classList.add('selected');
                } else {
                    const prev = this.selectedTile;
                    const dist = Math.abs(r - prev.r) + Math.abs(c - prev.c);

                    if (dist === 1) {
                        this.swap(prev.r, prev.c, r, c);
                    } else {
                        prev.el.classList.remove('selected');
                        if (prev.r === r && prev.c === c) {
                            this.selectedTile = null;
                        } else {
                            this.selectedTile = { r, c, el: tileEl };
                            tileEl.classList.add('selected');
                        }
                    }
                }
            },

            async swap(r1, c1, r2, c2) {
                this.isProcessing = true;
                const prevEl = this.selectedTile.el;
                const currEl = document.querySelector(`[data-row="${r2}"][data-col="${c2}"]`);
                
                prevEl.classList.remove('selected');
                this.selectedTile = null;

                // 交換數據
                const temp = this.grid[r1][c1];
                this.grid[r1][c1] = this.grid[r2][c2];
                this.grid[r2][c2] = temp;

                // 更新 UI
                prevEl.textContent = this.grid[r1][c1];
                currEl.textContent = this.grid[r2][c2];

                const matches = this.findMatches();
                if (matches.length > 0) {
                    await this.processMatches();
                } else {
                    // 沒匹配，換回來
                    await new Promise(resolve => setTimeout(resolve, 300));
                    const tempBack = this.grid[r1][c1];
                    this.grid[r1][c1] = this.grid[r2][c2];
                    this.grid[r2][c2] = tempBack;
                    prevEl.textContent = this.grid[r1][c1];
                    currEl.textContent = this.grid[r2][c2];
                    this.isProcessing = false;
                }
            },

            findMatches() {
                const matches = [];
                // 水平
                for (let r = 0; r < this.gridSize; r++) {
                    for (let c = 0; c < this.gridSize - 2; c++) {
                        const item = this.grid[r][c];
                        if (item && item === this.grid[r][c+1] && item === this.grid[r][c+2]) {
                            matches.push({r, c}, {r, c: c+1}, {r, c: c+2});
                        }
                    }
                }
                // 垂直
                for (let c = 0; c < this.gridSize; c++) {
                    for (let r = 0; r < this.gridSize - 2; r++) {
                        const item = this.grid[r][c];
                        if (item && item === this.grid[r+1][c] && item === this.grid[r+2][c]) {
                            matches.push({r, c}, {r: r+1, c}, {r: r+2, c});
                        }
                    }
                }
                // 去重
                return Array.from(new Set(matches.map(m => `${m.r},${m.c}`)))
                            .map(s => { const [r, c] = s.split(',').map(Number); return {r, c}; });
            },

            async processMatches() {
                const matches = this.findMatches();
                if (matches.length === 0) {
                    this.isProcessing = false;
                    return;
                }

                // 標記並動畫消除
                matches.forEach(m => {
                    const el = document.querySelector(`[data-row="${m.r}"][data-col="${m.c}"]`);
                    if (el) el.classList.add('match');
                });

                AudioSystem.playCorrect();
                this.score += matches.length * 10;
                document.getElementById('match3Score').textContent = this.score;

                await new Promise(resolve => setTimeout(resolve, 400));

                // 移除數據
                matches.forEach(m => {
                    this.grid[m.r][m.c] = null;
                });

                // 掉落
                this.dropItems();
                this.renderGrid();

                await new Promise(resolve => setTimeout(resolve, 300));
                await this.processMatches(); // 遞迴檢查連鎖反應
            },

            dropItems() {
                for (let c = 0; c < this.gridSize; c++) {
                    let emptyRow = this.gridSize - 1;
                    for (let r = this.gridSize - 1; r >= 0; r--) {
                        if (this.grid[r][c] !== null) {
                            this.grid[emptyRow][c] = this.grid[r][c];
                            if (emptyRow !== r) this.grid[r][c] = null;
                            emptyRow--;
                        }
                    }
                    // 補新方塊
                    for (let r = emptyRow; r >= 0; r--) {
                        this.grid[r][c] = this.items[Math.floor(Math.random() * this.items.length)];
                    }
                }
            }
        };

        // 記憶遊戲邏輯
        const ShootingGame = {
            score: 0,
            active: false,
            player: { x: 50, y: 85, speed: 0.6 }, // percent positions
            bullets: [], // {x,y,vy,el}
            enemies: [], // {x,y,vy,el,hp,score}
            lastTime: 0,
            fireCooldown: 0,
            enemyTimer: 0,
            keyState: {},
            rafId: null,
            bypass: true,
            // 不同分值的怪物：1/2/3 分與扣 1 分
            enemyTypes: [
                { name: 'ghost', icon: '👻', score: 1, color: '#66e3ff', speedMin: 0.04, speedMax: 0.07 },
                { name: 'bat',   icon: '🦇', score: 2, color: '#ffd54f', speedMin: 0.05, speedMax: 0.08 },
                { name: 'ogre',  icon: '👹', score: 3, color: '#ff5252', speedMin: 0.03, speedMax: 0.05 },
                { name: 'skull', icon: '💀', score: -1, color: '#ff1744', speedMin: 0.06, speedMax: 0.10 }
            ],
            enemyWeights: [0.5, 0.25, 0.15, 0.10],
            maxEnemies: 14,

            start(bypass = false) {
                this.bypass = bypass;
                // No star cost; admin access only for now
                this.reset();
                UIManager.showScreen('shooter');
                this.initUI();
                this.bindControls();
                this.active = true;
                this.lastTime = performance.now();
                this.rafId = requestAnimationFrame((t) => this.loop(t));
            },

            stop() {
                this.active = false;
                cancelAnimationFrame(this.rafId);
                this.unbindControls();
                this.clearEntities();
                UIManager.showScreen('map');
            },

            reset() {
                this.score = 0;
                this.player = { x: 50, y: 85, speed: 0.6 };
                this.bullets = [];
                this.enemies = [];
                this.fireCooldown = 0;
                this.enemyTimer = 0;
                const scoreEl = document.getElementById('shooterScore');
                if (scoreEl) scoreEl.textContent = '0';
            },

            initUI() {
                const c = document.getElementById('shooterContainer');
                if (!c) return;
                c.innerHTML = '';
                // player element
                const p = document.createElement('div');
                p.id = 'shooterPlayer';
                p.className = 'shooter-player';
                p.textContent = '🏹';
                c.appendChild(p);
                this.updatePlayerEl();
                // 分數圖示說明（右上角）
                const legend = document.createElement('div');
                legend.className = 'shooter-legend';
                legend.innerHTML = `
                    <div class="legend-row"><span class="icon" style="color:#66e3ff;">👻</span><span class="text">+1 分</span></div>
                    <div class="legend-row"><span class="icon" style="color:#ffd54f;">🦇</span><span class="text">+2 分（需射 2 次）</span></div>
                    <div class="legend-row"><span class="icon" style="color:#ff5252;">👹</span><span class="text">+3 分（需射 3 次）</span></div>
                    <div class="legend-row"><span class="icon" style="color:#ff1744;">💀</span><span class="text">-1 分</span></div>
                `;
                c.appendChild(legend);
                // Touch/mouse move support
                const moveTo = (clientX, clientY) => {
                    const rect = c.getBoundingClientRect();
                    const x = Math.max(0, Math.min(100, ((clientX - rect.left) / rect.width) * 100));
                    const y = Math.max(0, Math.min(100, ((clientY - rect.top) / rect.height) * 100));
                    this.player.x = x;
                    this.player.y = y;
                    this.updatePlayerEl();
                };
                c.onpointerdown = (e) => { moveTo(e.clientX, e.clientY); this.tryFire(); };
                c.onpointermove = (e) => { if (e.buttons) moveTo(e.clientX, e.clientY); };
            },

            bindControls() {
                this.keyState = {};
                this._keyDown = (e) => {
                    this.keyState[e.key.toLowerCase()] = true;
                    if (e.code === 'Space') { e.preventDefault(); this.tryFire(); }
                };
                this._keyUp = (e) => { this.keyState[e.key.toLowerCase()] = false; };
                window.addEventListener('keydown', this._keyDown);
                window.addEventListener('keyup', this._keyUp);
            },
            unbindControls() {
                window.removeEventListener('keydown', this._keyDown);
                window.removeEventListener('keyup', this._keyUp);
            },

            updatePlayerEl() {
                const p = document.getElementById('shooterPlayer');
                if (p) {
                    p.style.left = this.player.x + '%';
                    p.style.top = this.player.y + '%';
                }
            },

            tryFire() {
                if (this.fireCooldown > 0 || !this.active) return;
                this.fireCooldown = 180; // ms
                this.spawnBullet(this.player.x, this.player.y - 6);
                AudioSystem.playCorrect();
            },

            spawnBullet(x, y) {
                const c = document.getElementById('shooterContainer');
                if (!c) return;
                const el = document.createElement('div');
                el.className = 'shooter-bullet';
                el.style.left = x + '%';
                el.style.top = y + '%';
                c.appendChild(el);
                this.bullets.push({ x, y, vy: -0.35, el });
            },

            spawnEnemy() {
                const c = document.getElementById('shooterContainer');
                if (!c) return;
                // 決定這一輪要生幾隻
                let toSpawn = Math.random() < 0.35 ? 2 : 1;
                while (toSpawn-- > 0 && this.enemies.length < this.maxEnemies) {
                    // 依權重選型
                    const r = Math.random();
                    let acc = 0;
                    let type = this.enemyTypes[0];
                    for (let i = 0; i < this.enemyTypes.length; i++) {
                        acc += this.enemyWeights[i] || 0;
                        if (r <= acc) { type = this.enemyTypes[i]; break; }
                    }
                    const el = document.createElement('div');
                    el.className = 'shooter-enemy';
                    el.textContent = type.icon;
                    const x = 5 + Math.random() * 90;
                    const y = -5 - Math.random() * 5;
                    el.style.left = x + '%';
                    el.style.top = y + '%';
                    // 不同類型稍微不同的發光顏色
                    el.style.filter = `drop-shadow(0 0 10px ${type.color})`;
                    // 3 分怪（ogre）更大且更亮
                    if (type.name === 'ogre') {
                        el.style.width = '72px';
                        el.style.height = '72px';
                        el.style.fontSize = '64px';
                        el.style.filter = `drop-shadow(0 0 14px ${type.color}) saturate(1.2)`;
                        el.classList.add('ogre-boss');
                    }
                    c.appendChild(el);
                    const speed = type.speedMin + Math.random() * (type.speedMax - type.speedMin);
                    const hp = type.score > 0 ? type.score : 1; // 2分要射2次，3分要射3次，其餘1次
                    this.enemies.push({ x, y, vy: speed, el, hp, score: type.score });
                }
            },

            explosion(x, y, color = '#ffd700') {
                const c = document.getElementById('shooterContainer');
                if (!c) return;
                const el = document.createElement('div');
                el.className = 'shooter-explosion';
                el.style.left = x + '%';
                el.style.top = y + '%';
                el.style.borderColor = color;
                c.appendChild(el);
                requestAnimationFrame(() => {
                    el.style.transform = 'translate(-50%, -50%) scale(1.6)';
                    el.style.opacity = '0';
                });
                setTimeout(() => el.remove(), 280);
            },

            clearEntities() {
                const c = document.getElementById('shooterContainer');
                if (!c) return;
                [...c.querySelectorAll('.shooter-bullet,.shooter-enemy,.shooter-explosion')].forEach(n => n.remove());
            },

            loop(timestamp) {
                if (!this.active) return;
                const dt = Math.min(50, timestamp - this.lastTime);
                this.lastTime = timestamp;
                // cooldown timers
                this.fireCooldown = Math.max(0, this.fireCooldown - dt);
                this.enemyTimer += dt;
                if (this.enemyTimer > 550) { this.enemyTimer = 0; this.spawnEnemy(); }

                // keyboard movement
                const speed = (this.player.speed * dt);
                if (this.keyState['a'] || this.keyState['arrowleft']) this.player.x -= speed;
                if (this.keyState['d'] || this.keyState['arrowright']) this.player.x += speed;
                if (this.keyState['w'] || this.keyState['arrowup']) this.player.y -= speed;
                if (this.keyState['s'] || this.keyState['arrowdown']) this.player.y += speed;
                this.player.x = Math.max(5, Math.min(95, this.player.x));
                this.player.y = Math.max(10, Math.min(95, this.player.y));
                this.updatePlayerEl();

                // update bullets
                for (let i = this.bullets.length - 1; i >= 0; i--) {
                    const b = this.bullets[i];
                    b.y += b.vy * (dt);
                    if (b.el) b.el.style.top = b.y + '%';
                    if (b.y < -5) { b.el && b.el.remove(); this.bullets.splice(i, 1); }
                }
                // update enemies
                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    const e = this.enemies[i];
                    e.y += e.vy * (dt);
                    if (e.el) e.el.style.top = e.y + '%';
                    // check reach bottom -> penalty
                    if (e.y > 105) {
                        // 掉落到底部不扣分，直接移除
                        e.el && e.el.remove();
                        this.enemies.splice(i, 1);
                    }
                }
                // collisions bullet-enemy
                for (let bi = this.bullets.length - 1; bi >= 0; bi--) {
                    const b = this.bullets[bi];
                    for (let ei = this.enemies.length - 1; ei >= 0; ei--) {
                        const e = this.enemies[ei];
                        const dx = (b.x - e.x);
                        const dy = (b.y - e.y);
                        if (Math.abs(dx) < 5 && Math.abs(dy) < 8) {
                            // hit
                            b.el && b.el.remove();
                            this.bullets.splice(bi, 1);
                            e.hp -= 1;
                            if (e.hp <= 0) {
                                const delta = (typeof e.score === 'number') ? e.score : 1;
                                const positive = delta > 0;
                                this.explosion(e.x, e.y, positive ? '#ffd700' : '#ff1744');
                                e.el && e.el.remove();
                                this.enemies.splice(ei, 1);
                                if (positive) {
                                    this.score += delta;
                                    AudioSystem.playCorrect();
                                } else {
                                    this.score = Math.max(0, this.score + delta); // delta 為負
                                    AudioSystem.playWrong();
                                }
                                const se = document.getElementById('shooterScore');
                                if (se) se.textContent = String(this.score);
                            }
                            break;
                        }
                    }
                }

                // simple win condition
                if (this.score >= 100) {
                    this.showWin();
                    return;
                }

                this.rafId = requestAnimationFrame((t) => this.loop(t));
            },

            showWin() {
                this.active = false;
                cancelAnimationFrame(this.rafId);
                const c = document.getElementById('shooterContainer');
                if (!c) return;
                this.clearEntities();
                const overlay = document.createElement('div');
                overlay.style.cssText = 'position:absolute;inset:0;background:rgba(0,0,0,0.75);display:flex;flex-direction:column;align-items:center;justify-content:center;color:#fff;z-index:10;';
                overlay.innerHTML = '<h2 style="color:#ffd700;margin:8px 0;">🎉 恭喜過關！</h2><p style="margin:6px 0;">你擊敗了森林幽靈！</p>';
                const btn = document.createElement('button');
                btn.className = 'result-btn home-btn';
                btn.textContent = '返回地圖';
                btn.onclick = () => { this.stop(); };
                overlay.appendChild(btn);
                c.appendChild(overlay);
                AudioSystem.playComplete();
            }
        };

        const MemoryGame = {
            // 支援最多 18 對（36 張卡片）的圖示
            icons: ['🦊','🐰','🦉','🐻','🦌','🐗','🦝','🐹','🐿️','🐢','🦋','🐝','🐸','🦔','🦨','🦫','🦦','🦡'],
            cards: [],
            flippedCards: [],
            matchedPairs: 0,
            isProcessing: false,
            totalPairs: 12, // 預設為 12 對

            // 判斷是否可使用 18 對：大螢幕且高度也夠
            decidePairsCount() {
                const w = window.innerWidth || 0;
                const h = window.innerHeight || 0;
                const isLandscape = w > h;
                // 寬度、高度門檻可依實測微調
                if (isLandscape && w >= 1200 && h >= 700) return 18;
                return 12;
            },

            start(bypass = false) {
                if (!bypass) {
                    const available = UIManager.getAvailableStars();
                    if (available < 3) {
                        alert(`🌟 需要 3 顆可用星星才能玩「森林記憶王」喔！\n趕快去挑戰關卡賺取星星吧！`);
                        return;
                    }
                    if (!confirm(`確定要花費 3 顆星星開始「森林記憶王」嗎？`)) {
                        return;
                    }
                    if (!Storage.consumeStarsSequentially(3)) {
                        return;
                    }
                    UIManager.renderLevelMap();
                }
                this.initGame();
                UIManager.showScreen('memory');
            },

            stop() {
                UIManager.showScreen('map');
            },

            initGame() {
                this.matchedPairs = 0;
                this.flippedCards = [];
                this.isProcessing = false;

                // 根據螢幕條件決定要用 12 對還是 18 對
                this.totalPairs = this.decidePairsCount();

                // 清理可能的舊過關畫面
                const oldOverlay = document.getElementById('memoryWinOverlay');
                if (oldOverlay) oldOverlay.remove();

                // 更新配對顯示
                const pairsEl = document.getElementById('memoryPairs');
                if (pairsEl) pairsEl.textContent = '0';
                const totalEl = document.getElementById('memoryTotalPairs');
                if (totalEl) totalEl.textContent = String(this.totalPairs);
                
                // 準備卡片：依 totalPairs 取前 N 個圖示，倍增並洗牌
                const selected = this.icons.slice(0, this.totalPairs);
                const gameIcons = [...selected, ...selected];
                const shuffledIcons = Utils.shuffleArray(gameIcons);
                
                this.cards = shuffledIcons.map((icon, index) => ({
                    id: index,
                    icon: icon,
                    isFlipped: false,
                    isMatched: false
                }));
                
                this.renderGrid();
            },

            renderGrid() {
                const grid = document.getElementById('memoryGrid');
                if (!grid) return;
                grid.innerHTML = '';
                this.cards.forEach(card => {
                    const cardEl = document.createElement('div');
                    cardEl.className = 'memory-card';
                    cardEl.dataset.id = card.id;
                    cardEl.innerHTML = `
                        <div class="card-face card-front">${card.icon}</div>
                        <div class="card-face card-back"></div>
                    `;
                    cardEl.onclick = () => this.handleCardClick(card.id, cardEl);
                    grid.appendChild(cardEl);
                });
            },

            handleCardClick(id, el) {
                const card = this.cards[id];
                if (this.isProcessing || card.isFlipped || card.isMatched || this.flippedCards.length >= 2) return;
                
                // 翻開卡片
                card.isFlipped = true;
                el.classList.add('flipped');
                this.flippedCards.push({ card, el });
                
                if (this.flippedCards.length === 2) {
                    this.isProcessing = true;
                    setTimeout(() => this.checkMatch(), 600);
                }
            },

            checkMatch() {
                const [c1, c2] = this.flippedCards;
                if (c1.card.icon === c2.card.icon) {
                    // 匹配成功
                    c1.card.isMatched = true;
                    c2.card.isMatched = true;
                    
                    // 先加上一個短暫的成功類別來觸發動畫
                    c1.el.classList.add('matched');
                    c2.el.classList.add('matched');
                    
                    this.matchedPairs++;
                    const pairsEl = document.getElementById('memoryPairs');
                    if (pairsEl) pairsEl.textContent = this.matchedPairs;
                    AudioSystem.playCorrect();
                    
                    if (this.matchedPairs === this.totalPairs) {
                        setTimeout(() => this.winGame(), 800);
                    }
                } else {
                    // 匹配失敗
                    c1.card.isFlipped = false;
                    c2.card.isFlipped = false;
                    c1.el.classList.remove('flipped');
                    c2.el.classList.remove('flipped');
                    AudioSystem.playWrong();
                }
                
                this.flippedCards = [];
                this.isProcessing = false;
            },

            winGame() {
                AudioSystem.playComplete();
                
                const container = document.getElementById('memoryScreen');
                const winOverlay = document.createElement('div');
                winOverlay.id = 'memoryWinOverlay';
                winOverlay.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.85);
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: center;
                    color: white;
                    z-index: 200;
                    animation: modalSlideIn 0.5s ease;
                    text-align: center;
                    padding: 20px;
                    border-radius: 25px;
                `;
                
                winOverlay.innerHTML = `
                    <h2 style="font-size: clamp(28px, 6vw, 40px); color: #ffd700; margin-bottom: 15px; text-shadow: 0 0 10px rgba(255,215,0,0.5);">🎊 記憶大師 🎊</h2>
                    <div style="font-size: 60px; margin-bottom: 15px;">🌟🌟🌟</div>
                    <p style="font-size: clamp(18px, 4vw, 22px); margin-bottom: 25px;">太強了！你找出了所有森林夥伴！<br>你的記憶力真是令人驚嘆！</p>
                    <button class="result-btn home-btn" style="min-width: 200px;" onclick="MemoryGame.stop()">返回地圖</button>
                `;
                container.appendChild(winOverlay);
                
                const originalStop = this.stop;
                this.stop = () => {
                    winOverlay.remove();
                    originalStop.call(this);
                    this.stop = originalStop; // 還原
                };
            }
        };

        // 森林切切樂 小遊戲
        const FruitGame = {
            active: false,
            score: 0,
            fruits: [],
            rafId: 0,
            spawnTimer: 0,
            sliceActive: false,
            lastPoint: null,
            containerRect: null,
            emojis: ['🍎','🍌','🍊','🍉','🍇','🍓','🍍','🥝'],

            start(bypass = false) {
                if (!bypass) {
                    const available = UIManager.getAvailableStars();
                    if (available < 3) {
                        alert(`🌟 需要 3 顆可用星星才能玩「森林切切樂」喔！\n趕快去挑戰關卡賺取星星吧！`);
                        return;
                    }
                    if (!confirm(`確定要花費 3 顆星星開始「森林切切樂」嗎？`)) {
                        return;
                    }
                    if (!Storage.consumeStarsSequentially(3)) {
                        return;
                    }
                    UIManager.renderLevelMap();
                }
                this.reset();
                UIManager.showScreen('fruit');
                this.bindEvents();
                this.loop();
                this.scheduleSpawn();
            },

            stop() {
                this.active = false;
                cancelAnimationFrame(this.rafId);
                clearTimeout(this.spawnTimer);
                const c = document.getElementById('fruitContainer');
                if (c) c.innerHTML = '';
                UIManager.showScreen('map');
            },

            reset() {
                this.active = true;
                this.score = 0;
                this.fruits = [];
                this.sliceActive = false;
                this.lastPoint = null;
                const sc = document.getElementById('fruitScore');
                if (sc) sc.textContent = '0';
                const c = document.getElementById('fruitContainer');
                if (c) {
                    c.innerHTML = '';
                    this.containerRect = c.getBoundingClientRect();
                }
            },

            bindEvents() {
                const c = document.getElementById('fruitContainer');
                if (!c) return;
                const onDown = (e) => {
                    this.sliceActive = true;
                    const p = this.eventPoint(e);
                    this.lastPoint = p;
                    this.spawnTrail(p.x, p.y);
                };
                const onMove = (e) => {
                    if (!this.sliceActive) return;
                    const p = this.eventPoint(e);
                    this.spawnTrail(p.x, p.y);
                    this.checkSlice(this.lastPoint, p);
                    this.lastPoint = p;
                };
                const onUp = () => { this.sliceActive = false; this.lastPoint = null; };
                c.onpointerdown = onDown;
                c.onpointermove = onMove;
                c.onpointerup = onUp;
                c.onpointerleave = onUp;
                c.onpointercancel = onUp;
            },

            eventPoint(e) {
                const c = document.getElementById('fruitContainer');
                if (!c) return {x:0,y:0};
                const rect = c.getBoundingClientRect();
                const cx = (e.clientX !== undefined ? e.clientX : (e.touches && e.touches[0].clientX));
                const cy = (e.clientY !== undefined ? e.clientY : (e.touches && e.touches[0].clientY));
                return { x: cx - rect.left, y: cy - rect.top };
            },

            spawnTrail(x, y) {
                const c = document.getElementById('fruitContainer');
                if (!c) return;
                const dot = document.createElement('div');
                dot.className = 'slice-trail';
                dot.style.left = x + 'px';
                dot.style.top = y + 'px';
                c.appendChild(dot);
                setTimeout(() => dot.remove(), 500);
            },

            scheduleSpawn() {
                const interval = 1100 + Math.random() * 700; // 1.1s ~ 1.8s（更慢）
                this.spawnTimer = setTimeout(() => {
                    if (!this.active) return;
                    this.spawnFruit();
                    this.scheduleSpawn();
                }, interval);
            },

            spawnFruit() {
                const c = document.getElementById('fruitContainer');
                if (!c) return;
                const w = c.clientWidth;
                const h = c.clientHeight;

                // 隨機決定出現方向：上方、左側、右側
                // 預設仍以上方為主，左右兩側各給一定機率
                const r = Math.random();
                let x, y, vx, vy, ax, g;

                if (r < 0.6) {
                    // 上方生成：維持原本拋物線下落
                    x = 50 + Math.random() * (w - 100); // 稍微避開左右邊緣
                    y = -24; // 從上方外部進入
                    vx = (Math.random() * 2 - 1) * 1.0; // 左右位移稍減，整體更慢
                    vy = 0.7 + Math.random() * 0.9; // 更慢的初速
                    ax = (Math.random() * 2 - 1) * 0.012; // 水平加速度稍降，仍保有拋物線
                    // 重力（只給上方生成者，讓其落下）
                    g = 0.055 + Math.random() * 0.035;
                } else if (r < 0.8) {
                    // 從左側進場：直線飛向右側（不下落）
                    x = -24; // 從左邊界外
                    y = 20 + Math.random() * (h * 0.6);
                    vx = 3.2 + Math.random() * 1.8; // 往右的速度
                    vy = 0;                     // 不下落
                    ax = undefined;             // 不施加水平加速度，也避免速度夾限
                    g = 0;                      // 無重力
                } else {
                    // 從右側進場：直線飛向左側（不下落）
                    x = w + 24; // 從右邊界外
                    y = 20 + Math.random() * (h * 0.6);
                    vx = -(3.2 + Math.random() * 1.8); // 往左的速度
                    vy = 0;                     // 不下落
                    ax = undefined;             // 不施加水平加速度，也避免速度夾限
                    g = 0;                      // 無重力
                }

                const emoji = this.emojis[Math.floor(Math.random() * this.emojis.length)];
                const el = document.createElement('div');
                el.className = 'fruit';
                el.textContent = emoji;
                c.appendChild(el);
                const fruit = { x, y, vx, vy, g, ax, el, sliced: false, value: 5, emoji };
                this.fruits.push(fruit);
            },

            checkSlice(p1, p2) {
                if (!p1 || !p2) return;
                // 線段與圓距離簡化：用終點附近判斷即可
                this.fruits.forEach(f => {
                    if (f.sliced) return;
                    const dx = p2.x - f.x;
                    const dy = p2.y - f.y;
                    const dist = Math.hypot(dx, dy);
                    if (dist < 52) { // 命中判定稍微放大，符合更大的水果
                        this.sliceFruit(f);
                    }
                });
            },

            sliceFruit(fruit) {
                // 標記為已切，避免重複判定與扣分
                fruit.sliced = true;
                // 製作切開動畫效果（左右半邊 + 果汁）
                this.createSliceEffect(fruit.x, fruit.y, fruit.emoji);
                // 立即移除原本水果 DOM 與資料
                if (fruit.el && fruit.el.parentNode) fruit.el.remove();
                const idx = this.fruits.indexOf(fruit);
                if (idx >= 0) this.fruits.splice(idx, 1);
                // 加分與音效
                this.score += fruit.value;
                const sc = document.getElementById('fruitScore');
                if (sc) sc.textContent = String(this.score);
                AudioSystem.playCorrect();
                // 勝利條件
                if (this.score >= 100) {
                    this.showWin();
                }
            },

            createSliceEffect(x, y, emoji) {
                const c = document.getElementById('fruitContainer');
                if (!c) return;
                // 兩半
                const left = document.createElement('div');
                left.className = 'fruit-piece left';
                left.style.left = x + 'px';
                left.style.top = y + 'px';
                left.textContent = emoji;
                const right = document.createElement('div');
                right.className = 'fruit-piece right';
                right.style.left = x + 'px';
                right.style.top = y + 'px';
                right.textContent = emoji;
                c.appendChild(left);
                c.appendChild(right);
                // 果汁濺射（幾個泡泡）
                const splashCount = 5 + Math.floor(Math.random() * 4);
                for (let i = 0; i < splashCount; i++) {
                    const j = document.createElement('div');
                    j.className = 'fruit-juice';
                    const ox = (Math.random() * 80) - 40;
                    const oy = (Math.random() * 40) - 20;
                    j.style.left = (x + ox) + 'px';
                    j.style.top = (y + oy) + 'px';
                    c.appendChild(j);
                    setTimeout(() => j.remove(), 650);
                }
                // 清理半邊
                setTimeout(() => { left.remove(); right.remove(); }, 600);
            },

            loop() {
                if (!this.active) return;
                const c = document.getElementById('fruitContainer');
                if (!c) return;
                const h = c.clientHeight;
                const w = c.clientWidth;
                // 更新
                for (let i = this.fruits.length - 1; i >= 0; i--) {
                    const f = this.fruits[i];
                    // 物理更新：加入水平加速度，形成弧線軌跡
                    if (typeof f.ax === 'number') {
                        f.vx += f.ax;
                        // 夾限避免水平速度過大
                        if (f.vx > 2.2) f.vx = 2.2;
                        if (f.vx < -2.2) f.vx = -2.2;
                    }
                    f.vy += f.g;
                    f.x += f.vx;
                    f.y += f.vy;
                    // 邊界移除（配合更大的水果，放寬邊界緩衝）
                    if (f.y > h + 80 || f.y < -80 || f.x < -80 || f.x > w + 80) {
                        // 掉落不扣分：直接移除未切中的水果
                        if (f.el) f.el.remove();
                        this.fruits.splice(i,1);
                        continue;
                    }
                    // 繪製
                    f.el.style.left = f.x + 'px';
                    f.el.style.top = f.y + 'px';
                }
                this.rafId = requestAnimationFrame(() => this.loop());
            },

            showWin() {
                this.active = false;
                cancelAnimationFrame(this.rafId);
                clearTimeout(this.spawnTimer);
                const c = document.getElementById('fruitContainer');
                if (!c) return;
                const overlay = document.createElement('div');
                overlay.style.cssText = 'position:absolute;inset:0;background:rgba(0,0,0,0.75);display:flex;flex-direction:column;align-items:center;justify-content:center;color:#fff;z-index:10;';
                overlay.innerHTML = '<h2 style="color:#ffd700;margin:8px 0;">🎉 恭喜過關！</h2><p style="margin:6px 0;">刀法了得！你是切水果高手！</p>';
                const btn = document.createElement('button');
                btn.className = 'result-btn home-btn';
                btn.textContent = '返回地圖';
                btn.onclick = () => { this.stop(); };
                overlay.appendChild(btn);
                c.appendChild(overlay);
                AudioSystem.playComplete();
            }
        };
        
        const STORY_MAZE_HARD_QUESTIONS = [
            { q: "小光有38塊積木，小華給他16塊後，小光又借給同學15塊，小光現在有幾塊積木？", options: ["39塊", "37塊", "22塊", "7塊"], answer: "39塊" },
            { q: "小傑家裡有24本故事書，爸爸又買了18本，爺爺也送來15本，現在小傑家一共有幾本故事書？", options: ["57本", "49本", "42本", "62本"], answer: "57本" },
            { q: "教室裡原本有14枝粉筆，第一節課先用5枝，第二節課再用4枝，現在還有幾枝粉筆？", options: ["5枝", "13枝", "23枝", "9枝"], answer: "5枝" },
            { q: "會議室裡有40張椅子，先搬走18張，後來再搬走12張，會議室裡還剩幾張椅子？", options: ["10張", "34張", "46張", "58張"], answer: "10張" },
            { q: "桶子裡原有7個綠色海洋球球，先放進去6個紅色海洋球，再放進去2個黃色海洋球，桶子裡合起來有幾個海洋球？", options: ["15個", "11個", "13個", "9個"], answer: "15個" },
            { q: "1枝榴槤冰棒是46元，1枝紅豆牛奶冰棒比榴槤冰棒少19元，1枝果枝冰棒比紅豆牛奶冰棒少9元，1枝果枝冰棒是幾元？", options: ["18元", "27元", "10元", "37元"], answer: "18元" },
            { q: "游泳池提供20個黃色浮板和10個藍色浮板，被借走15個，游泳池還剩下幾個浮板？", options: ["15個", "25個", "5個", "10個"], answer: "15個" },
            { q: "媽媽買了60顆糖果，先分給哥哥18顆，再分給妹妹25顆，媽媽還剩幾顆糖果？", options: ["17顆", "19顆", "21顆", "27顆"], answer: "17顆" },
            { q: "媽媽去超市買東西，她買了一罐28元的牛奶、一個15元的麵包和一份35元的沙拉，媽媽共花了多少元？", options: ["78元", "68元", "88元", "73元"], answer: "78元" },
            { q: "書架上原有11本雜誌，小華先放入8本故事書，再放入9本繪本，書架上現在共有幾本書？", options: ["28本", "29本", "27本", "20本"], answer: "28本" },
            { q: "小美做了25個白巧克力和36個黑巧克力，送給小芳19個後，還剩下幾個巧克力？", options: ["42個", "80個", "30個", "61個"], answer: "42個" },
            { q: "阿潭帶60元去超商買了18元的茶葉蛋和32元的麵包後，還剩下幾元？", options: ["10元", "46元", "42元", "28元"], answer: "10元" },
            { q: "小美有26張貼紙，小芳送她18張，小英又送她14張，小美現在共有幾張貼紙？", options: ["58張", "57張", "40張", "44張"], answer: "58張" },
            { q: "小美買了30張圖畫紙，先送給小欣7張，再送給小怡9張，小美還剩幾張圖畫紙？", options: ["14張", "12張", "10張", "23張"], answer: "14張" },
            { q: "糖果袋裡有70顆糖果，小珍吃了25顆，小美又放入18顆，糖果袋裡現在有幾顆糖果？", options: ["63顆", "52顆", "45顆", "77顆"], answer: "63顆" },
            { q: "小明今天要背20個英文單字，上午先背9個，下午再背7個，小明還有幾個單字沒背？", options: ["4個", "18個", "36個", "22個"], answer: "4個" },
            { q: "箱子裡有74包袖珍包面紙，爸爸拿去35包後，媽媽又放入17包，箱子裡現在有幾包袖珍包面紙？", options: ["56包", "45包", "39包", "66包"], answer: "56包" },
            { q: "班上做卡片，第一組做了22張，第二組做了18張，第三組做了19張，一共做了幾張卡片？", options: ["59張", "60張", "69張", "40張"], answer: "59張" },
            { q: "圖書室原有40本童書，上午歸還了35本圖畫書，下午歸還了15本百科書。現在圖書室共有幾本書？", options: ["90本", "95本", "100本", "80本"], answer: "90本" },
            { q: "阿閎採了22個柳丁，小君比阿閎少採8個，兩人共採了幾個柳丁？", options: ["36個", "33個", "30個", "38個"], answer: "36個" },
            { q: "冷藏櫃裡有25瓶鮮奶，上午賣出7瓶，下午又賣出6瓶，冷藏櫃裡還剩幾瓶鮮奶？", options: ["12瓶", "13瓶", "18瓶", "17瓶"], answer: "12瓶" },
            { q: "遊樂場的旋轉木馬可以容納45個小朋友，現在有20個小朋友在上面，又上來15個，最多還可以再上來幾個小朋友？", options: ["5個", "7個", "10個", "15個"], answer: "10個" },
            { q: "媽媽買了13個柳丁和7個蘋果，後來又加買17個奇異果，媽媽共買了幾個水果？", options: ["37個", "35個", "36個", "27個"], answer: "37個" },
            { q: "桶子裡有25顆乒乓球，姐姐取出12顆，妹妹取出9顆，桶子裡還剩幾顆乒乓球？", options: ["4顆", "5顆", "6顆", "13顆"], answer: "4顆" },
            { q: "倉庫裡有85箱蘋果，上午先運走30箱，下午再運走28箱，倉庫還剩幾箱蘋果？", options: ["27箱", "143箱", "87箱", "83箱"], answer: "27箱" },
            { q: "籃球比賽中，小強第一節得了12分，第二節得了15分，第三節又得了8分，他共得了幾分？", options: ["35分", "36分", "27分", "20分"], answer: "35分" },
            { q: "小米原有58元，買飲料用去30元，爸爸又給他27元，小米現在有幾元？", options: ["55元", "18元", "1元", "65元"], answer: "55元" },
            { q: "紅茶、綠茶和青茶共65杯，紅茶有21杯，青茶有24杯，綠茶有幾杯？", options: ["20杯", "15杯", "25杯", "30杯"], answer: "20杯" },
            { q: "球池裡有54個人，25個人離開後，又進來16個人，球池裡現在有幾個人？", options: ["45個", "13個", "38個", "95個"], answer: "45個" },
            { q: "教室的書架上，故事書有40本，科學書有23本，動物書有17本，這三類書共幾本？", options: ["80本", "79本", "81本", "34本"], answer: "80本" },
            { q: "水果店有32個奇異果，上午先賣了13個，下午又賣了18個，水果店還剩下幾個奇異果？", options: ["1個", "37個", "27個", "19個"], answer: "1個" },
            { q: "書架上有18本小說和7本故事書，美華借走10本書後，書架上還剩下幾本書？", options: ["15本", "13本", "17本", "25本"], answer: "15本" },
            { q: "計算「34＋25＋16＝？」，正確答案是多少？", options: ["75", "65", "85", "70"], answer: "75" },
            { q: "媽媽在第一間水果攤買了15個奇異果，在第二間又買了17個，全家人一起吃掉20個後，還剩幾個奇異果？", options: ["12個", "32個", "52個", "22個"], answer: "12個" },
            { q: "盒子裡有20個雞塊，爸爸吃了6個，媽媽吃了7個，盒子裡還剩幾個雞塊？", options: ["7個", "6個", "19個", "14個"], answer: "7個" },
            { q: "計算「18＋22＋30＝？」，正確答案是多少？", options: ["70", "60", "80", "72"], answer: "70" },
            { q: "飲料店準備了30杯紅茶、25杯奶茶和20杯綠茶。今天一共準備了幾杯飲料？", options: ["75杯", "70杯", "80杯", "65杯"], answer: "75杯" },
            { q: "小芸今天要寫45題作業，上午先寫18題，下午再寫17題，還剩幾題沒寫？", options: ["10題", "11題", "12題", "20題"], answer: "10題" },
            { q: "二年1班有14個男生和13個女生，今日有9個學生請假，有來上課的學生是幾個？", options: ["18個", "17個", "19個", "27個"], answer: "18個" },
            { q: "博物館裡有85個遊客，36個遊客離開後，又進來20個，博物館裡現在有幾個遊客？", options: ["69個", "29個", "105個", "141個"], answer: "69個" },
            { q: "體育老師登記運動會項目，短跑有32個人報名，接力賽有25個人報名，跳遠有18個人報名，共有幾個人報名參加比賽？", options: ["75個", "74個", "39個", "57個"], answer: "75個" },
            { q: "小豪有90元，買玩具用了35元，又買飲料用了28元，小豪還剩下幾元？", options: ["27元", "83元", "97元", "55元"], answer: "27元" },
            { q: "計算「21＋33＋19＝？」，正確答案是多少？", options: ["73", "63", "83", "71"], answer: "73" },
            { q: "教室的書架上原有55本書，上午先借出24本，下午再借出20本，書架上還剩幾本書？", options: ["11本", "51本", "59本", "31本"], answer: "11本" },
            { q: "咖啡廳最多可以提供35個座位，現在有18個人，又進來14個，最多還可以再進來幾個人？", options: ["3個", "39個", "31個", "32個"], answer: "3個" },
            { q: "阿依帶80元去水果店買了45元的奇異果和32元的香蕉後，還剩下幾元？", options: ["3元", "35元", "48元", "13元"], answer: "3元" },
            { q: "書架上原有55本書，小華拿走28本後，小芳又放入16本，現在書架上有幾本書？", options: ["43本", "67本", "11本", "27本"], answer: "43本" },
            { q: "小偉寫國語作業花了20分鐘，數學作業花了15分鐘，自然作業又花了25分鐘，小偉寫作業共花了幾分鐘？", options: ["60分鐘", "61分鐘", "70分鐘", "30分鐘"], answer: "60分鐘" },
            { q: "小豪原本有20元，爸爸給他14元後，媽媽再給他13元，小豪現在有多少元？", options: ["47元", "57元", "67元", "37元"], answer: "47元" },
            { q: "小米有50元，買早餐用去18元，買飲料用去20元，小米還剩幾元？", options: ["12元", "14元", "13元", "22元"], answer: "12元" }
        ];

        const Utils = {
            shuffleArray(array) {
                const newArray = [...array];
                for (let i = newArray.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
                }
                return newArray;
            },
            generateOptions(correctAnswer, range) {
                const options = [correctAnswer];
                let attempts = 0;
                while (options.length < 4 && attempts < 100) {
                    attempts++;
                    let option;
                    if (typeof correctAnswer === 'number') {
                        // 根據正確答案的大小來決定偏移量，避免在大數額時偏移太小
                        const magnitude = Math.max(1, Math.pow(10, Math.floor(Math.log10(correctAnswer || 1)) - 1));
                        const offset = (Math.floor(Math.random() * 21) - 10) * magnitude;
                        option = correctAnswer + offset;
                        if (option < 0) option = Math.abs(option);
                        if (option > range && range > 0) option = option % (range + 1);
                    } else {
                        option = Math.floor(Math.random() * range);
                    }
                    if (!options.includes(option) && option >= 0) {
                        options.push(option);
                    }
                }
                // 如果失敗，強制填滿
                while (options.length < 4) {
                    const lastOption = options[options.length - 1];
                    options.push(typeof lastOption === 'number' ? lastOption + 1 : options.length);
                }
                return this.shuffleArray(options);
            },
            generateMultiplicationOptions(correct) {
                const options = [correct];
                const possibleAnswers = [];
                for (let i = 2; i <= 9; i++) {
                    for (let j = 2; j <= 9; j++) {
                        const result = i * j;
                        if (result !== correct && Math.abs(result - correct) <= 20) {
                            possibleAnswers.push(result);
                        }
                    }
                }
                while (options.length < 4 && possibleAnswers.length > 0) {
                    const randomIndex = Math.floor(Math.random() * possibleAnswers.length);
                    const option = possibleAnswers[randomIndex];
                    if (!options.includes(option)) {
                        options.push(option);
                    }
                    possibleAnswers.splice(randomIndex, 1);
                }
                let attempts = 0;
                while (options.length < 4 && attempts < 100) {
                    attempts++;
                    const offset = Math.floor(Math.random() * 10) + 1;
                    const option = Math.random() > 0.5 ? correct + offset : correct - offset;
                    if (option > 0 && !options.includes(option)) {
                        options.push(option);
                    }
                }
                // 如果失敗，強制填滿
                while (options.length < 4) {
                    const lastOption = options[options.length - 1];
                    options.push(lastOption + 1);
                }
                return this.shuffleArray(options);
            },
            generateDynamicStory() {
                const types = [
                    {
                        // 型態 1: A + B - C (先增加後減少)
                        templates: [
                            { unit: "塊", text: (a, b, c) => `小光有 ${a} 塊積木，小華給他 ${b} 塊後，小光又借給同學 ${c} 塊，小光現在有幾塊積木？` },
                            { unit: "個人", text: (a, b, c) => `球池裡原本有 ${a} 個人，又進來了 ${b} 個人，後來離開了 ${c} 個人，現在球池裡有幾個人？` },
                            { unit: "個人", text: (a, b, c) => `公車上原本有 ${a} 個人，到站後上來了 ${b} 個人，又下車了 ${c} 個人，現在車上有幾個人？` }
                        ],
                        logic: () => {
                            const a = Math.floor(Math.random() * 30) + 20; // 20-50
                            const b = Math.floor(Math.random() * 20) + 10; // 10-30
                            const c = Math.floor(Math.random() * (a + b - 10)) + 5; // 確保剩餘至少10
                            const ans = a + b - c;
                            return { vars: [a, b, c], answer: ans };
                        }
                    },
                    {
                        // 型態 2: A - B - C (連續減少)
                        templates: [
                            { unit: "顆", text: (a, b, c) => `媽媽買了 ${a} 顆糖果，分給哥哥 ${b} 顆，又分給妹妹 ${c} 顆，媽媽還剩幾顆糖果？` },
                            { unit: "元", text: (a, b, c) => `小豪有 ${a} 元，買文具用了 ${b} 元，買飲料用了 ${c} 元，小豪還剩下幾元？` },
                            { unit: "個", text: (a, b, c) => `箱子裡有 ${a} 個蘋果，上午運走 ${b} 個，下午又運走 ${c} 個，箱子還剩幾個蘋果？` }
                        ],
                        logic: () => {
                            const a = Math.floor(Math.random() * 40) + 50; // 50-90
                            const b = Math.floor(Math.random() * 20) + 10; // 10-30
                            const c = Math.floor(Math.random() * (a - b - 10)) + 5; // 確保剩餘至少10
                            const ans = a - b - c;
                            return { vars: [a, b, c], answer: ans };
                        }
                    },
                    {
                        // 型態 3: A + B + C (三項加法)
                        templates: [
                            { unit: "個", text: (a, b, c) => `水果店有 ${a} 個蘋果、${b} 個橘子和 ${c} 個梨子，這三種水果共有幾個？` },
                            { unit: "個", text: (a, b, c) => `小美第一節課背了 ${a} 個單字，第二節背了 ${b} 個，第三節又背了 ${c} 個，小美共背了幾個單字？` },
                            { unit: "位", text: (a, b, c) => `二年級一班有 ${a} 個男生，二班有 ${b} 個男生，三班有 ${c} 個男生，這三個班共有幾個男生？` }
                        ],
                        logic: () => {
                            const a = Math.floor(Math.random() * 20) + 10; // 10-30
                            const b = Math.floor(Math.random() * 20) + 10; // 10-30
                            const c = Math.floor(Math.random() * 20) + 10; // 10-30
                            const ans = a + b + c;
                            return { vars: [a, b, c], answer: ans };
                        }
                    }
                ];

                const type = types[Math.floor(Math.random() * types.length)];
                const data = type.logic();
                const templateObj = type.templates[Math.floor(Math.random() * type.templates.length)];
                
                const q = templateObj.text(...data.vars);
                const unit = templateObj.unit;

                // 生成干擾選項
                const ans = data.answer;
                const options = [ans];
                
                // 增加錯誤路徑干擾
                const [a, b, c] = data.vars;
                const distractor1 = a + b + c; // 誤加
                const distractor2 = Math.abs(a - b - c); // 誤減
                const distractor3 = a + b; // 漏掉最後一步
                
                [distractor1, distractor2, distractor3].forEach(d => {
                    if (d !== ans && d > 0 && !options.includes(d)) options.push(d);
                });

                // 如果還不足 4 個，使用隨機偏移
                let attempts = 0;
                while (options.length < 4 && attempts < 100) {
                    attempts++;
                    const offset = Math.floor(Math.random() * 10) + 1;
                    const opt = Math.random() > 0.5 ? ans + offset : ans - offset;
                    if (opt > 0 && !options.includes(opt)) options.push(opt);
                }
                // 如果失敗，強制填滿
                while (options.length < 4) {
                    const lastOption = options[options.length - 1];
                    options.push(lastOption + 1);
                }
                
                return {
                    question: q,
                    answer: ans + unit,
                    options: this.shuffleArray(options.map(o => o + unit))
                };
            },
            getCoinSvg(value) {
                const colors = {
                    1: { bg: '#e67e22', border: '#d35400', text: '#fff' },
                    5: { bg: '#95a5a6', border: '#7f8c8d', text: '#fff' },
                    10: { bg: '#f1c40f', border: '#f39c12', text: '#8b4513' },
                    50: { bg: '#f1c40f', border: '#d35400', text: '#8b4513' },
                    100: { bg: '#e74c3c', border: '#c0392b', text: '#fff' },
                    500: { bg: '#2ecc71', border: '#27ae60', text: '#fff' },
                    1000: { bg: '#3498db', border: '#2980b9', text: '#fff' }
                };
                const c = colors[value] || colors[1];
                const isBill = value >= 100;
                if (isBill) {
                    const fontSize = value >= 1000 ? 22 : 26;
                    return `<svg viewBox="0 0 100 60" xmlns="http://www.w3.org/2000/svg">
                        <rect x="2" y="2" width="96" height="56" rx="5" fill="${c.bg}" stroke="${c.border}" stroke-width="2"/>
                        <circle cx="50" cy="30" r="15" fill="none" stroke="${c.border}" stroke-width="1" opacity="0.5"/>
                        <text x="50" y="38" font-family="Arial" font-size="${fontSize}" font-weight="bold" fill="${c.text}" text-anchor="middle">${value}</text>
                    </svg>`;
                }
                return `<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                    <circle cx="50" cy="50" r="45" fill="${c.bg}" stroke="${c.border}" stroke-width="3"/>
                    <circle cx="50" cy="50" r="35" fill="none" stroke="${c.border}" stroke-width="1" stroke-dasharray="2,2"/>
                    <text x="50" y="65" font-family="Arial" font-size="40" font-weight="bold" fill="${c.text}" text-anchor="middle">${value}</text>
                </svg>`;
            }
        };

        const AudioSystem = {
            context: null,
            init() {
                this.context = new (window.AudioContext || window.webkitAudioContext)();
            },
            playCorrect() {
                try {
                    if (!this.context) this.init();
                    if (this.context.state === 'suspended') this.context.resume();
                    const oscillator = this.context.createOscillator();
                    const gainNode = this.context.createGain();
                    oscillator.connect(gainNode);
                    gainNode.connect(this.context.destination);
                    oscillator.frequency.setValueAtTime(523.25, this.context.currentTime);
                    oscillator.frequency.setValueAtTime(659.25, this.context.currentTime + 0.1);
                    oscillator.frequency.setValueAtTime(783.99, this.context.currentTime + 0.2);
                    gainNode.gain.setValueAtTime(0.3, this.context.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.3);
                    oscillator.start(this.context.currentTime);
                    oscillator.stop(this.context.currentTime + 0.3);
                } catch (e) {
                    console.error('Audio play error:', e);
                }
            },
            playWrong() {
                try {
                    if (!this.context) this.init();
                    if (this.context.state === 'suspended') this.context.resume();
                    const oscillator = this.context.createOscillator();
                    const gainNode = this.context.createGain();
                    oscillator.connect(gainNode);
                    gainNode.connect(this.context.destination);
                    oscillator.frequency.setValueAtTime(200, this.context.currentTime);
                    oscillator.type = 'sawtooth';
                    gainNode.gain.setValueAtTime(0.3, this.context.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.2);
                    oscillator.start(this.context.currentTime);
                    oscillator.stop(this.context.currentTime + 0.2);
                } catch (e) {
                    console.error('Audio play error:', e);
                }
            },
            playComplete() {
                try {
                    if (!this.context) this.init();
                    if (this.context.state === 'suspended') {
                        this.context.resume().then(() => this._playCompleteNotes());
                    } else {
                        this._playCompleteNotes();
                    }
                } catch (e) {
                    console.error('Audio play error:', e);
                }
            },
            _playCompleteNotes() {
                try {
                    const notes = [523.25, 587.33, 659.25, 783.99];
                    notes.forEach((freq, i) => {
                        const oscillator = this.context.createOscillator();
                        const gainNode = this.context.createGain();
                        oscillator.connect(gainNode);
                        gainNode.connect(this.context.destination);
                        oscillator.frequency.setValueAtTime(freq, this.context.currentTime + i * 0.15);
                        gainNode.gain.setValueAtTime(0.2, this.context.currentTime + i * 0.15);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + i * 0.15 + 0.3);
                        oscillator.start(this.context.currentTime + i * 0.15);
                        oscillator.stop(this.context.currentTime + i * 0.15 + 0.3);
                    });
                } catch (e) {
                    console.error('Notes play error:', e);
                }
            }
        };

        const Levels = [
            {
                id: 1,
                name: '數字魔法師',
                icon: '🧙‍♂️',
                generateQuestion: (difficulty) => {
                    const isEasy = difficulty === 'easy';
                    let num1, num2, operator, answer;
                    if (isEasy) {
                        operator = Math.random() > 0.5 ? '+' : '-';
                        if (operator === '+') {
                            num1 = Math.floor(Math.random() * 9) + 1;
                            num2 = Math.floor(Math.random() * (10 - num1)) + 1;
                            answer = num1 + num2;
                        } else {
                            answer = Math.floor(Math.random() * 9) + 1;
                            num2 = Math.floor(Math.random() * answer) + 1;
                            num1 = answer + num2;
                            answer = num1 - num2;
                        }
                    } else {
                        operator = Math.random() > 0.5 ? '+' : '-';
                        if (operator === '+') {
                            num1 = Math.floor(Math.random() * 90) + 10;
                            num2 = Math.floor(Math.random() * (100 - num1)) + 1;
                            answer = num1 + num2;
                        } else {
                            answer = Math.floor(Math.random() * 90) + 10;
                            num2 = Math.floor(Math.random() * answer) + 1;
                            num1 = answer + num2;
                            answer = num1 - num2;
                        }
                    }
                    return {
                        question: `${num1} ${operator} ${num2} = ?`,
                        answer: answer,
                        options: Utils.generateOptions(answer, isEasy ? 10 : 100)
                    };
                }
            },
            {
                id: 2,
                name: '故事迷宮',
                icon: '📖',
                generateQuestion: (difficulty) => {
                    const isEasy = difficulty === 'easy';
                    if (isEasy) {
                        const scenarios = [
                            (a, b) => ({
                                q: `小明有 ${a} 顆糖果，媽媽又給他 ${b} 顆，小明現在有幾顆糖果？`,
                                a: a + b
                            }),
                            (a, b) => ({
                                q: `樹上有 ${a} 隻小鳥，飛走了 ${b} 隻，還剩下幾隻小鳥？`,
                                a: a - b
                            }),
                            (a, b) => ({
                                q: `籃子裡有 ${a} 顆蘋果，小華吃掉 ${b} 顆，還剩下幾顆蘋果？`,
                                a: a - b
                            }),
                            (a, b) => ({
                                q: `書架上原本有 ${a} 本故事書，爸爸又買了 ${b} 本給小明，現在書架上共有幾本書？`,
                                a: a + b
                            }),
                            (a, b) => ({
                                q: `花園裡開了 ${a} 朵紅花，旁邊還有 ${b} 朵黃花，花園裡總共有幾朵花？`,
                                a: a + b
                            }),
                            (a, b) => ({
                                q: `小豬撲滿裡有 ${a} 元，小美今天又存進去 ${b} 元，現在撲滿裡有多少錢？`,
                                a: a + b
                            }),
                            (a, b) => ({
                                q: `停車場裡停了 ${a} 輛紅色汽車和 ${b} 輛藍色汽車，停車場裡總共有幾輛車？`,
                                a: a + b
                            }),
                            (a, b) => ({
                                q: `停車場原本有 ${a} 輛車，開走了 ${b} 輛，現在停車場還剩下幾輛車？`,
                                a: a - b
                            }),
                            (a, b) => ({
                                q: `冰箱裡有 ${a} 顆雞蛋，媽媽做蛋糕用掉了 ${b} 顆，冰箱還剩下幾顆雞蛋？`,
                                a: a - b
                            }),
                            (a, b) => ({
                                q: `小丑手上有 ${a} 個氣球，不小心飛走了 ${b} 個，小丑手上還剩下幾個氣球？`,
                                a: a - b
                            }),
                            (a, b) => ({
                                q: `公車上原本有 ${a} 個人，到了車站後下車了 ${b} 個人，現在車上還有幾個人？`,
                                a: a - b
                            })
                        ];
                        const scenario = scenarios[Math.floor(Math.random() * scenarios.length)];
                        const num1 = Math.floor(Math.random() * 15) + 5;
                        const num2 = Math.floor(Math.random() * num1) + 1;
                        const result = scenario(num1, num2);
                        return {
                            question: result.q,
                            answer: result.a,
                            options: Utils.generateOptions(result.a, 20)
                        };
                    } else {
                        // 困難模式：50% 機率從題庫抽題，50% 機率隨機生成
                        if (Math.random() > 0.5) {
                            return Utils.generateDynamicStory();
                        } else {
                            const randomIdx = Math.floor(Math.random() * STORY_MAZE_HARD_QUESTIONS.length);
                            const qData = STORY_MAZE_HARD_QUESTIONS[randomIdx];
                            return {
                                question: qData.q,
                                answer: qData.answer,
                                options: Utils.shuffleArray([...qData.options])
                            };
                        }
                    }
                }
            },
            {
                id: 3,
                name: '乘法探險家',
                icon: '✖️',
                generateQuestion: (difficulty) => {
                    const isEasy = difficulty === 'easy';
                    let num1, num2;
                    if (isEasy) {
                        const multipliers = [2, 3, 4, 5];
                        num1 = multipliers[Math.floor(Math.random() * multipliers.length)];
                        num2 = Math.floor(Math.random() * 9) + 1;
                    } else {
                        num1 = Math.floor(Math.random() * 9) + 1;
                        num2 = Math.floor(Math.random() * 9) + 1;
                    }
                    const answer = num1 * num2;
                    return {
                        question: `${num1} × ${num2} = ?`,
                        answer: answer,
                        options: Utils.generateOptions(answer, isEasy ? 50 : 81)
                    };
                }
            },
            {
                id: 4,
                name: '大小魔王戰',
                icon: '⚔️',
                generateQuestion: (difficulty) => {
                    const isEasy = difficulty === 'easy';
                    let num1, num2;
                    if (isEasy) {
                        num1 = Math.floor(Math.random() * 90) + 10;
                        num2 = Math.floor(Math.random() * 90) + 10;
                    } else {
                        num1 = Math.floor(Math.random() * 900) + 100;
                        num2 = Math.floor(Math.random() * 900) + 100;
                    }
                    let answer;
                    if (num1 > num2) answer = '>';
                    else if (num1 < num2) answer = '<';
                    else answer = '=';
                    return {
                        question: `${num1} _____ ${num2}`,
                        answer: answer,
                        options: ['<', '>', '='],
                        isComparison: true
                    };
                }
            },
            {
                id: 5,
                name: '錢幣大富翁',
                icon: '💰',
                generateQuestion: (difficulty) => {
                    const isEasy = difficulty === 'easy';
                    const coinConfigs = isEasy ? [
                        { value: 1, max: 10 },
                        { value: 5, max: 5 },
                        { value: 10, max: 3 }
                    ] : [
                        { value: 1, max: 10 },
                        { value: 5, max: 5 },
                        { value: 10, max: 5 },
                        { value: 50, max: 2 },
                        { value: 100, max: 2 },
                        { value: 500, max: 2 },
                        { value: 1000, max: 1 }
                    ];

                    // 隨機選取 2-4 種錢幣
                    const selectedConfigs = Utils.shuffleArray(coinConfigs).slice(0, isEasy ? 2 : 4);
                    // 按照幣值大到小排序，視覺上比較整齊
                    selectedConfigs.sort((a, b) => b.value - a.value);
                    let total = 0;
                    let coinsHtml = '';

                    selectedConfigs.forEach(config => {
                        const count = Math.floor(Math.random() * config.max) + 1;
                        total += config.value * count;
                        coinsHtml += `<div class="coin-row">`;
                        for (let i = 0; i < count; i++) {
                            const isBill = config.value >= 100;
                            const billClass = isBill ? 'is-bill' : '';
                            coinsHtml += `
                                <div class="coin-wrapper ${billClass}" style="margin: 1px;">
                                    <div class="coin-img">${Utils.getCoinSvg(config.value)}</div>
                                </div>
                            `;
                        }
                        coinsHtml += `<div class="coin-row-count">x ${count}</div>`;
                        coinsHtml += `</div>`;
                    });

                    return {
                        question: `你有這些錢，總共有多少元？`,
                        coinsHtml: coinsHtml,
                        answer: total,
                        options: Utils.generateOptions(total, isEasy ? 100 : 3000)
                    };
                }
            },
            {
                id: 6,
                name: '時間魔法鐘',
                icon: '🕐',
                generateQuestion: (difficulty) => {
                    const isEasy = difficulty === 'easy';
                    let hour, minute, answer;
                    if (isEasy) {
                        // Easy mode: 5-minute intervals
                        hour = Math.floor(Math.random() * 12) + 1;
                        minute = Math.floor(Math.random() * 12) * 5;
                    } else {
                        // Hard mode: 1-minute intervals
                        hour = Math.floor(Math.random() * 12) + 1;
                        minute = Math.floor(Math.random() * 60);
                    }
                    const formatTime = (h, m) => `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
                    answer = formatTime(hour, minute);
                    return {
                        question: '現在是幾點？',
                        answer: answer,
                        hour: hour,
                        minute: minute,
                        options: generateTimeOptions(hour, minute, isEasy),
                        isClock: true
                    };
                }
            }
        ];

        // 獨立的練習關卡
        const PracticeLevels = [
            {
                id: 99,
                name: '九九乘法王',
                icon: '🔢',
                generateQuestion: (difficulty) => {
                    const isEasy = difficulty === 'easy';
                    let num1, num2;

                    if (isEasy) {
                        // 簡單模式：2-5的乘法表
                        num1 = Math.floor(Math.random() * 4) + 2;
                        num2 = Math.floor(Math.random() * 8) + 2;
                    } else {
                        // 困難模式：完整九九乘法表 2-9
                        num1 = Math.floor(Math.random() * 8) + 2;
                        num2 = Math.floor(Math.random() * 8) + 2;
                    }

                    const answer = num1 * num2;

                    // 產生更具挑戰性的選項
                    return {
                        question: `${num1} × ${num2} = ?`,
                        answer: answer,
                        options: Utils.generateMultiplicationOptions(answer)
                    };
                }
            }
        ];

        function generateTimeOptions(hour, minute, isEasy) {
            const formatTime = (h, m) => `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
            const correctAnswer = formatTime(hour, minute);
            const options = [correctAnswer];

            if (!isEasy) {
                // 困難模式：強制加入小時數 +-1 的選項
                const prevHour = hour - 1 < 1 ? 12 : hour - 1;
                const nextHour = hour + 1 > 12 ? 1 : hour + 1;

                const opt1 = formatTime(prevHour, minute);
                const opt2 = formatTime(nextHour, minute);

                if (!options.includes(opt1)) options.push(opt1);
                if (!options.includes(opt2)) options.push(opt2);
            }

            let attempts = 0;
            while (options.length < 4 && attempts < 100) {
                attempts++;
                // 步驟 1: 讓小時 h 接近答案 hour (+- 1 小時)
                let h;
                const hourRange = 1; // 接近範圍：+- 1 小時

                // 在 [hour - 1, hour + 1] 範圍內隨機生成小時 (但需考慮 12 小時制)
                const minH = hour - hourRange;
                const maxH = hour + hourRange;

                // 隨機在 minH 到 maxH 之間生成 h
                h = Math.floor(Math.random() * (maxH - minH + 1)) + minH;

                // 處理 h 超出 1-12 範圍的情況，例如 12 + 1 = 1， 1 - 1 = 12
                h = (h < 1) ? 12 : (h > 12) ? 1 : h;

                // 步驟 2: 讓分鐘 m 接近答案 minute (+- 15 分鐘)
                let m;
                const minuteRange = isEasy ? 15 : 5;
                const minM = Math.max(0, minute - minuteRange);
                const maxM = Math.min(59, minute + minuteRange);

                if (isEasy) {
                    // 在接近範圍內生成 5 的倍數
                    m = Math.floor(Math.random() * 12) * 5;
                } else {
                    // 在接近範圍內生成任意分鐘
                    m = Math.floor(Math.random() * 60);
                }

                const option = formatTime(h, m);
                if (!options.includes(option)) {
                    options.push(option);
                }
            }

            // 如果失敗，強制填滿
            while (options.length < 4) {
                const lastOption = options[options.length - 1];
                const [h, m] = lastOption.split(':').map(Number);
                options.push(formatTime(h, (m + 5) % 60));
            }
            return Utils.shuffleArray(options);
        }

        function drawClock(hour, minute) {
            const container = document.getElementById('clockContainerInner');
            if (!container) return;
            let ticksHtml = '';
            for (let i = 0; i < 60; i++) {
                const isHour = i % 5 === 0;
                const h = isHour ? 15 : 8; // %
                const w = isHour ? 2 : 1; // px
                const angle = i * 6;

                ticksHtml += `<div class="clock-tick" style="width: ${w}px; height: 50%; transform: translateX(-50%) rotate(${angle}deg);">
                    <div class="clock-tick-inner" style="height: ${h}%;"></div>
                </div>`;
            }

            let numbersHtml = '';
            for (let i = 1; i <= 12; i++) {
                const angleRad = (i * 30 - 90) * (Math.PI / 180);
                const radius = 38;
                const x = 50 + radius * Math.cos(angleRad);
                const y = 50 + radius * Math.sin(angleRad);
                numbersHtml += `<div class="clock-number" style="left: ${x}%; top: ${y}%">${i}</div>`;
            }
            container.innerHTML = `
                ${ticksHtml}
                ${numbersHtml}
                <div class="clock-center"></div>
                <div class="clock-hand hour-hand" id="hourHand"></div>
                <div class="clock-hand minute-hand" id="minuteHand"></div>
            `;
            
            // 使用 setTimeout 確保 DOM 已渲染，從而觸發 CSS transition
            setTimeout(() => {
                const hourHand = document.getElementById('hourHand');
                const minuteHand = document.getElementById('minuteHand');
                if (hourHand && minuteHand) {
                    hourHand.style.transform = `rotate(${(hour % 12) * 30 + minute * 0.5}deg)`;
                    minuteHand.style.transform = `rotate(${minute * 6}deg)`;
                }
            }, 50);
        }

        const Storage = {
            getRecord(levelId, difficulty) {
                const key = `level_${levelId}_${difficulty}`;
                return parseInt(localStorage.getItem(key)) || 0;
            },
            saveRecord(levelId, difficulty, stars) {
                const key = `level_${levelId}_${difficulty}`;
                const current = this.getRecord(levelId, difficulty);
                if (stars > current) {
                    localStorage.setItem(key, stars);
                }
            },
            getUsedStars() {
                return parseInt(localStorage.getItem('stars_used')) || 0;
            },
            useStars(count) {
                const current = this.getUsedStars();
                localStorage.setItem('stars_used', current + count);
            },
            consumeStarsSequentially(count) {
                let remainingToConsume = count;
                // 定義順序：關卡 1->6，每個關卡先扣簡單再扣困難
                for (let levelId = 1; levelId <= 6; levelId++) {
                    const difficulties = ['easy', 'hard'];
                    for (const diff of difficulties) {
                        if (remainingToConsume <= 0) break;
                        
                        const key = `level_${levelId}_${diff}`;
                        let stars = parseInt(localStorage.getItem(key)) || 0;
                        
                        if (stars > 0) {
                            const consume = Math.min(stars, remainingToConsume);
                            stars -= consume;
                            remainingToConsume -= consume;
                            
                            if (stars > 0) {
                                localStorage.setItem(key, stars);
                            } else {
                                localStorage.removeItem(key);
                            }
                        }
                    }
                    if (remainingToConsume <= 0) break;
                }
                
                // 既然現在直接扣除關卡星星，清除舊有的 stars_used 以免混亂
                localStorage.removeItem('stars_used');
                
                return remainingToConsume === 0;
            },
            addStars(count) {
                // 依序把星星加到各關卡：1→6，每關先把「簡單」補滿到 3，再補「困難」到 3，然後再到下一關
                let remaining = Math.max(0, parseInt(count) || 0);
                if (remaining <= 0) return 0;
                let added = 0;
                for (let levelId = 1; levelId <= 6 && remaining > 0; levelId++) {
                    // 先補簡單
                    const easyKey = `level_${levelId}_easy`;
                    let easyStars = parseInt(localStorage.getItem(easyKey)) || 0;
                    if (easyStars < 3 && remaining > 0) {
                        const canAdd = Math.min(3 - easyStars, remaining);
                        easyStars += canAdd;
                        localStorage.setItem(easyKey, easyStars);
                        remaining -= canAdd;
                        added += canAdd;
                    }
                    // 再補困難
                    const hardKey = `level_${levelId}_hard`;
                    let hardStars = parseInt(localStorage.getItem(hardKey)) || 0;
                    if (hardStars < 3 && remaining > 0) {
                        const canAdd = Math.min(3 - hardStars, remaining);
                        hardStars += canAdd;
                        localStorage.setItem(hardKey, hardStars);
                        remaining -= canAdd;
                        added += canAdd;
                    }
                }
                return added;
            },
            clearAllRecords() {
                const keys = Object.keys(localStorage);
                keys.forEach(key => {
                    if (key.startsWith('level_') || key === 'stars_used') {
                        localStorage.removeItem(key);
                    }
                });
            }
        };

        const GameEngine = {
            state: {
                currentLevel: null,
                difficulty: null,
                questionIndex: 0,
                errors: 0,
                correctCount: 0,
                totalQuestions: 10,
                questions: [],
                isPracticeMode: false
            },

            init() {
                AudioSystem.init();
                UIManager.renderLevelMap();
            },

            startLevel(levelId, difficulty) {
                const level = Levels.find(l => l.id === levelId);
                if (!level) return;

                UIManager.closeModal();

                this.state = {
                    currentLevel: level,
                    difficulty: difficulty,
                    questionIndex: 0,
                    errors: 0,
                    correctCount: 0,
                    totalQuestions: 10,
                    questions: [],
                    isPracticeMode: false
                };

                for (let i = 0; i < this.state.totalQuestions; i++) {
                    this.state.questions.push(level.generateQuestion(difficulty));
                }

                UIManager.showScreen('game');
                UIManager.updateGameUI();
                this.showQuestion();
            },

            startPractice(levelId) {
                const level = PracticeLevels.find(l => l.id === levelId);
                if (!level) return;

                this.state = {
                    currentLevel: level,
                    difficulty: 'practice',
                    questionIndex: 0,
                    errors: 0,
                    correctCount: 0,
                    totalQuestions: Infinity,
                    questions: [],
                    isPracticeMode: true,
                    lastPracticeQuestion: null
                };

                UIManager.showScreen('game');
                UIManager.updatePracticeUI();
                this.generateNewPracticeQuestion();
            },

            showQuestion() {
                const question = this.state.questions[this.state.questionIndex];
                UIManager.renderQuestion(question, (selected, btn) => this.checkAnswer(selected, btn));
            },

            checkAnswer(selected, btnElement) {
                try {
                    const currentQuestion = this.state.isPracticeMode 
                        ? this.state.lastPracticeQuestion
                        : this.state.questions[this.state.questionIndex];
                    
                    if (!currentQuestion) {
                        console.error('Current question is undefined');
                        this.nextQuestion();
                        return;
                    }

                    const isCorrect = selected === currentQuestion.answer;
                    this.handleAnswer(isCorrect, selected, currentQuestion.answer, btnElement);
                } catch (e) {
                    console.error('Error in checkAnswer:', e);
                    this.nextQuestion();
                }
            },

            generateNewPracticeQuestion() {
                try {
                    const question = this.state.currentLevel.generateQuestion(this.state.difficulty);
                    this.state.lastPracticeQuestion = question;
                    UIManager.renderQuestion(question, (selected, btn) => this.checkAnswer(selected, btn));
                } catch (e) {
                    console.error('Error in generateNewPracticeQuestion:', e);
                }
            },

            handleAnswer(isCorrect, selected, correctAnswer, btnElement) {
                try {
                    UIManager.disableAnswerButtons();

                    if (isCorrect) {
                        if (btnElement) btnElement.classList.add('correct');
                        AudioSystem.playCorrect();
                        this.state.correctCount++;
                        
                        setTimeout(() => {
                            this.nextQuestion();
                        }, 1000);
                    } else {
                        if (btnElement) btnElement.classList.add('wrong');
                        AudioSystem.playWrong();
                        this.state.errors++;
                        UIManager.updateErrorCount(this.state.errors);
                        UIManager.highlightCorrectAnswer(correctAnswer);

                        if (!this.state.isPracticeMode && this.state.errors >= 3) {
                            setTimeout(() => this.endGame(), 1000);
                        } else {
                            setTimeout(() => this.nextQuestion(), this.state.isPracticeMode ? 2000 : 1000);
                        }
                    }
                } catch (e) {
                    console.error('Error in handleAnswer:', e);
                    this.nextQuestion();
                }
            },

            nextQuestion() {
                try {
                    this.state.questionIndex++;
                    if (!this.state.isPracticeMode && this.state.questionIndex >= this.state.totalQuestions) {
                        this.endGame();
                    } else {
                        if (this.state.isPracticeMode) {
                            UIManager.updatePracticeUI();
                            this.generateNewPracticeQuestion();
                        } else {
                            UIManager.updateGameUI();
                            this.showQuestion();
                        }
                    }
                } catch (e) {
                    console.error('Error in nextQuestion:', e);
                    this.endGame();
                }
            },

            endGame() {
                try {
                    const stars = this.calculateStars();
                    Storage.saveRecord(this.state.currentLevel.id, this.state.difficulty, stars);
                    UIManager.showResult(stars, this.state.correctCount, this.state.totalQuestions);
                } catch (e) {
                    console.error('Error in endGame:', e);
                    UIManager.showScreen('map');
                }
            },

            calculateStars() {
                if (this.state.errors === 0) return 3;
                if (this.state.errors === 1) return 2;
                if (this.state.errors === 2) return 1;
                return 0;
            },

            retryLevel() {
                UIManager.hideResult();
                this.startLevel(this.state.currentLevel.id, this.state.difficulty);
            },

            backToMap() {
                UIManager.showScreen('map');
            }
        };

        const UIManager = {
            getTotalStars() {
                let total = 0;
                Levels.forEach(level => {
                    total += Storage.getRecord(level.id, 'easy');
                    total += Storage.getRecord(level.id, 'hard');
                });
                return total;
            },

            getAvailableStars() {
                return this.getTotalStars();
            },

            hasThreeStars() {
                let found = false;
                Levels.forEach(level => {
                    if (Storage.getRecord(level.id, 'easy') === 3 || Storage.getRecord(level.id, 'hard') === 3) {
                        found = true;
                    }
                });
                return found;
            },

            renderLevelMap() {
                const mapContainer = document.getElementById('levelMap');
                mapContainer.innerHTML = '';
                Levels.forEach(level => {
                    const easyStars = Storage.getRecord(level.id, 'easy');
                    const hardStars = Storage.getRecord(level.id, 'hard');
                    const card = document.createElement('div');
                    card.className = 'level-card';
                    card.onclick = () => this.openDifficultyModal(level.id);
                    card.innerHTML = `
                        <div class="level-icon">${level.icon}</div>
                        <h3>${level.name}</h3>
                        <div class="level-records">
                            <div class="record-item">
                                <div class="label">簡單</div>
                                <div class="stars">${'⭐'.repeat(easyStars)}${'☆'.repeat(3 - easyStars)}</div>
                            </div>
                            <div class="record-item">
                                <div class="label">困難</div>
                                <div class="stars">${'⭐'.repeat(hardStars)}${'☆'.repeat(3 - hardStars)}</div>
                            </div>
                        </div>
                    `;
                    mapContainer.appendChild(card);
                });

                const practiceContainer = document.getElementById('practiceMap');
                practiceContainer.innerHTML = '';
                PracticeLevels.forEach(level => {
                    const card = document.createElement('div');
                    card.className = 'practice-card';
                    card.onclick = () => GameEngine.startPractice(level.id);
                    card.innerHTML = `
                        <div class="practice-icon">${level.icon}</div>
                        <h3>${level.name}</h3>
                        <div class="practice-description">
                            無限練習模式<br>
                            💪 持續挑戰九九乘法表 💪<br>
                            <small>無錯誤限制 • 無時間壓力</small>
                        </div>
                    `;
                    practiceContainer.appendChild(card);
                });

                // 更新可用星星顯示
                const starsDisplay = document.getElementById('availableStarsDisplay');
                if (starsDisplay) {
                    const available = this.getAvailableStars();
                    starsDisplay.textContent = `🌟 當前可用星星: ${available} 🌟`;
                }
            },

            openDifficultyModal(levelId) {
                const level = Levels.find(l => l.id === levelId);
                GameEngine.state.currentLevel = level;
                const modal = document.getElementById('difficultyModal');
                document.getElementById('modalTitle').textContent = `${level.name} - 選擇難度`;
                modal.classList.add('active');
            },

            closeModal() {
                document.getElementById('difficultyModal').classList.remove('active');
            },

            openAdminModal() {
                const modal = document.getElementById('adminGameModal');
                if (modal) {
                    modal.classList.add('active');
                    // 初始化星星預覽
                    const maxEl = document.getElementById('adminStarsMax');
                    const curEl = document.getElementById('adminStarsCurrent');
                    const deltaEl = document.getElementById('adminStarsDelta');
                    const afterEl = document.getElementById('adminStarsAfter');
                    const input = document.getElementById('adminAddStarsInput');
                    const max = this.getMaxTotalStars();
                    const cur = this.getTotalStars();
                    if (maxEl) maxEl.textContent = String(max);
                    if (curEl) curEl.textContent = String(cur);
                    if (deltaEl) deltaEl.textContent = '0';
                    if (afterEl) afterEl.textContent = String(cur);
                    if (input) input.value = '0';
                }
            },

            closeAdminModal() {
                const modal = document.getElementById('adminGameModal');
                if (modal) modal.classList.remove('active');
            },

            getMaxTotalStars() {
                try {
                    return (Array.isArray(Levels) ? Levels.length : 6) * 2 * 3;
                } catch { return 36; }
            },

            adminUpdateStarPreview() {
                const input = document.getElementById('adminAddStarsInput');
                const curEl = document.getElementById('adminStarsCurrent');
                const deltaEl = document.getElementById('adminStarsDelta');
                const afterEl = document.getElementById('adminStarsAfter');
                const maxEl = document.getElementById('adminStarsMax');
                const max = this.getMaxTotalStars();
                const current = this.getTotalStars();
                let delta = parseInt(input && input.value || '0') || 0;
                // clamp delta to capacity
                if (delta > 0) delta = Math.min(delta, max - current);
                if (delta < 0) delta = -Math.min(-delta, current);
                if (input) input.value = String(delta);
                if (curEl) curEl.textContent = String(current);
                if (deltaEl) deltaEl.textContent = String(delta);
                if (afterEl) afterEl.textContent = String(current + delta);
                if (maxEl) maxEl.textContent = String(max);
            },

            adminQuickAdd(n) {
                const input = document.getElementById('adminAddStarsInput');
                if (!input) return;
                const max = this.getMaxTotalStars();
                const currentTotal = this.getTotalStars();
                let val = parseInt(input.value || '0') || 0;
                val += n;
                if (val > 0) val = Math.min(val, max - currentTotal);
                if (val < 0) val = -Math.min(-val, currentTotal);
                input.value = String(val);
                this.adminUpdateStarPreview();
            },

            adminApplyStars() {
                try {
                    const input = document.getElementById('adminAddStarsInput');
                    let delta = parseInt(input && input.value || '0') || 0;
                    const max = this.getMaxTotalStars();
                    const before = this.getTotalStars();
                    // capacity clamps
                    if (delta > 0) delta = Math.min(delta, max - before);
                    if (delta < 0) delta = -Math.min(-delta, before);
                    if (delta === 0) { alert('沒有可套用的調整。'); return; }

                    let ok = true; let applied = 0;
                    if (delta > 0) {
                        applied = Storage.addStars(delta);
                        ok = applied === delta;
                    } else if (delta < 0) {
                        const count = -delta;
                        ok = Storage.consumeStarsSequentially(count);
                        applied = count; // 因為已經夠可扣
                    }

                    // 重繪並回首頁
                    this.renderLevelMap();
                    this.closeAdminModal();
                    this.showScreen('map');

                    const after = this.getTotalStars();
                    alert(`星星已調整：${before} → ${after}（${delta > 0 ? '+' : ''}${after - before}）`);
                } catch (e) {
                    console.error('adminApplyStars error', e);
                    alert('操作失敗，請稍後再試。');
                }
            },

            adminAddStars() {
                try {
                    const input = document.getElementById('adminAddStarsInput');
                    const val = parseInt(input && input.value || '0');
                    const toAdd = Math.max(0, val || 0);
                    if (toAdd <= 0) { alert('請輸入要增加的星星數（至少 1 顆）'); return; }
                    const added = Storage.addStars(toAdd);
                    if (added > 0) {
                        this.renderLevelMap();
                        this.closeAdminModal();
                        this.showScreen('map');
                        alert(`已增加 ${added} 顆星星！`);
                    } else {
                        alert('目前所有關卡的簡單/困難紀錄都已是 3 顆星，沒有可新增的空位。');
                    }
                } catch (e) {
                    console.error('adminAddStars error', e);
                    alert('操作失敗，請稍後再試。');
                }
            },

            openResultBonusModal() {
                const modal = document.getElementById('resultBonusModal');
                if (modal) modal.classList.add('active');
            },

            closeResultBonusModal() {
                const modal = document.getElementById('resultBonusModal');
                if (modal) modal.classList.remove('active');
            },

            showScreen(screen) {
                const map = document.getElementById('levelMap');
                const practice = document.querySelector('.practice-section');
                const miniGame = document.querySelector('.mini-game-section');
                const reset = document.getElementById('resetSection');
                const title = document.querySelector('.game-title');
                const directBonus = document.getElementById('directBonusSection');
                
                const screens = {
                    'game': document.getElementById('gameScreen'),
                    'result': document.getElementById('resultScreen'),
                    'bonus': document.getElementById('bonusScreen'),
                    'match3': document.getElementById('match3Screen'),
                    'memory': document.getElementById('memoryScreen'),
                    'shooter': document.getElementById('shooterScreen'),
                    'fruit': document.getElementById('fruitScreen')
                };

                // 隱藏地圖相關
                [map, practice, miniGame, reset, title, directBonus].forEach(el => {
                    if (el) el.style.display = 'none';
                });

                // 隱藏所有遊戲畫面
                Object.values(screens).forEach(el => {
                    if (el) {
                        el.style.display = 'none';
                        el.classList.remove('active');
                    }
                });

                if (screen === 'map') {
                    map.style.display = 'grid';
                    practice.style.display = 'block';
                    if (miniGame) miniGame.style.display = 'block';
                    if (reset) reset.style.display = 'block';
                    title.style.display = 'block';
                    if (directBonus) directBonus.style.display = 'block';
                    this.renderLevelMap();
                } else if (screens[screen]) {
                    screens[screen].style.display = 'block';
                    screens[screen].classList.add('active');
                }
            },

            updateGameUI() {
                const state = GameEngine.state;
                document.getElementById('levelName').textContent = state.currentLevel.name;
                document.getElementById('questionNumber').textContent = state.questionIndex + 1;
                document.getElementById('totalQuestions').textContent = state.totalQuestions;
                document.getElementById('errorCount').textContent = state.errors;
                
                // Show game elements
                document.getElementById('errorCount').parentElement.style.display = 'block';
                document.getElementById('progressFill').parentElement.style.display = 'block';
                
                const progress = (state.questionIndex / state.totalQuestions) * 100;
                document.getElementById('progressFill').style.width = progress + '%';
            },

            updatePracticeUI() {
                const state = GameEngine.state;
                document.getElementById('levelName').textContent = state.currentLevel.name + ' - 練習模式';
                document.getElementById('questionNumber').textContent = state.questionIndex + 1;
                document.getElementById('totalQuestions').textContent = '∞';

                // Hide unnecessary elements
                document.getElementById('errorCount').parentElement.style.display = 'none';
                document.getElementById('progressFill').parentElement.style.display = 'none';
            },

            updateErrorCount(count) {
                document.getElementById('errorCount').textContent = count;
            },

            renderQuestion(question, onAnswer) {
                const questionContent = document.getElementById('questionContent');
                const answersContainer = document.getElementById('answersContainer');
                const clockContainer = document.getElementById('clockContainer');

                questionContent.textContent = question.question;
                clockContainer.innerHTML = '';
                answersContainer.innerHTML = '';

                if (question.coinsHtml) {
                    const coinDiv = document.createElement('div');
                    coinDiv.className = 'coin-container';
                    coinDiv.innerHTML = question.coinsHtml;
                    clockContainer.appendChild(coinDiv);
                }

                if (question.isClock) {
                    const clockDiv = document.createElement('div');
                    clockDiv.id = 'clockContainerInner';
                    clockDiv.className = 'clock-canvas';
                    clockContainer.appendChild(clockDiv);
                    drawClock(question.hour, question.minute);
                }

                question.options.forEach(option => {
                    const btn = document.createElement('button');
                    btn.className = 'answer-btn';
                    btn.textContent = option;
                    btn.onclick = () => onAnswer(option, btn);
                    answersContainer.appendChild(btn);
                });
            },

            disableAnswerButtons() {
                document.querySelectorAll('.answer-btn').forEach(btn => {
                    btn.disabled = true;
                    btn.style.cursor = 'not-allowed';
                });
            },

            highlightCorrectAnswer(correctAnswer) {
                document.querySelectorAll('.answer-btn').forEach(btn => {
                    if (btn.textContent === String(correctAnswer)) {
                        btn.classList.add('correct');
                    }
                });
            },

            showResult(stars, correctCount, totalQuestions) {
                this.showScreen('result');
                const resultTitle = document.getElementById('resultTitle');
                const resultStars = document.getElementById('resultStars');
                const resultMessage = document.getElementById('resultMessage');
                const bonusBtn = document.getElementById('bonusBtn');

                if (bonusBtn) {
                    bonusBtn.style.display = stars === 3 ? 'block' : 'none';
                }

                if (stars === 3) {
                    resultTitle.textContent = '太棒了！完美過關！';
                    resultMessage.textContent = `你答對了全部 ${totalQuestions} 題！`;
                    AudioSystem.playComplete();
                } else if (stars > 0) {
                    resultTitle.textContent = '做得好！';
                    resultMessage.textContent = `你答對了 ${correctCount} 題，繼續加油！`;
                    AudioSystem.playComplete();
                } else {
                    resultTitle.textContent = '再接再厲！';
                    resultMessage.textContent = `這次答對了 ${correctCount} 題，下次一定會更好！`;
                }
                resultStars.textContent = '⭐'.repeat(stars) + '☆'.repeat(3 - stars);
            },

            hideResult() {
                document.getElementById('resultScreen').classList.remove('active');
            },

            confirmExit() {
                if (confirm('確定要離開遊戲嗎？進度將不會保存。')) {
                    GameEngine.backToMap();
                }
            },

            confirmReset() {
                if (confirm('確定要清除所有獲得的星星嗎？這項動作無法復原喔！')) {
                    Storage.clearAllRecords();
                    this.renderLevelMap();
                    alert('已清除所有星星記錄！');
                }
            }
        };


        window.onload = () => {
            GameEngine.init();
        };
    </script>
</body>

</html>